# -*- coding: utf-8 -*-
# Task 7 - Final Integrated Heuristic Optimizer (stabilized)
# Author: (you)
# Last Update: 2025-10-16
#
# 改动要点：
# 1) 首版定容温和化：引入 ALPHA_OCCUPANCY，对并发估计做经验缩放，避免一上来就“炸数”
# 2) 步长闸门：MAX_STEP_PER_ITER 限制每轮净增/减的柜数，防止单轮大跳
# 3) 总量硬上限：CAP_TOTAL_LOCKERS（相对 baseline 倍数）防越界
# 4) 停止条件：SLA 达标 + 收益边际改进阈值 + 最低日SLA底线 + 平均体积利用率下限 + 迭代上限/不变即停
# 5) 代码保持与你的 Task_5_Slow_UtSpace.py 的接口一致（通过 safe_replace_assign 写入参数）

from __future__ import annotations
import os, sys, re, json, time, subprocess
from pathlib import Path
from typing import Dict, Any, List, Optional

import pandas as pd
import numpy as np
from scipy.stats import poisson

print("--- [Task 7] Final Heuristic Optimizer Initializing ---")

# ========= 目标与阈值 =========
TARGET_SERVICE_LEVEL   = 0.995   # 目标总体SLA
MIN_DAILY_SL_FLOOR     = 0.990   # 最低日SLA底线，避免个别极端日太差
REVENUE_IMPROVE_EPS    = 1_000.0 # 收益边际改进阈值，小于此视为“没必要再调”
MIN_UTILIZATION_MEAN   = 0.35    # 体积平均利用率的下限（避免太空）
MAX_ITERATIONS         = 20      # 迭代上限轮数
MIN_LOCKERS_PER_SIZE   = 5       # 各尺寸最小保留数

# ========= 首版定容温和化与调节闸门 =========
ALPHA_OCCUPANCY     = 0.85  # 并发校准系数（经验/仿真校准 0.8~0.9）
MAX_STEP_PER_ITER   = 3     # 每轮最多净变动的柜数（跨尺寸合计）
UTIL_SWAP_THRESHOLD = 0.80  # 若其他尺寸体积利用率 < 0.80，优先“交换”而非纯加总量

# ========= 路径与模拟器 =========
BASE_DIR = Path(__file__).resolve().parent
SIMULATOR_SCRIPT_SRC = BASE_DIR / "Task_5_Slow_UtSpace.py"  # 确保是最新版本
OUTPUT_DIR = BASE_DIR / "Task_7_Outcome_Final"
OUTPUT_DIR.mkdir(exist_ok=True)

# ========= 案例中的关键比例（需与你 Task1/3 对齐）=========
PEAK_4_WEEK_SHARE      = 0.13
PEAK_DAY_OF_WEEK_SHARE = 0.20

# 尺寸概率（按空间需求分布聚合成 S/M/L）
SPACE_REQUIREMENT_PROB = {
    'small' : 0.08 + 0.12 + 0.15,                                     # 1-3 ft³
    'medium': 0.12 + 0.08 + 0.06 + 0.05 + 0.05 + 0.05,                 # 4-9 ft³(4-9的前半可按你的口径微调)
    'large' : 0.04 + 0.04 + 0.03 + 0.03 + 0.03 + 0.02 + 0.02 + 0.02 + 0.01  # 10-18 ft³
}

# 每尺寸名义容量（ft³）
LOCKER_CAPACITY_FT3 = {'small': 3.0, 'medium': 9.0, 'large': 18.0}

# 年度需求场景（与你的 case 一致即可）
SCENARIO_DEMANDS = {
    '1.1': 50000, '1.2': 60000, '1.3': 80000, '2.1': 60000, '2.2': 65000, '2.3': 70000, '2.4': 90000, '2.5': 100000,
    '3.1': 60000, '3.2': 70000, '3.3': 75000, '3.4': 100000, '3.5': 110000, '4.1': 60000, '4.2': 75000, '4.3': 80000,
    '4.4': 105000, '4.5': 120000, '5.1': 60000, '5.2': 65000, '5.3': 90000, '5.4': 110000, '5.5': 150000
}

# 基线设计（可替换为你 Task1/2 的 baseline）
BASELINE_DESIGN = {'small': 27, 'medium': 32, 'large': 18}

# 总量硬上限（相对 baseline 的倍数上限，可按需改 1.4~1.8）
CAP_TOTAL_LOCKERS = int(1.6 * sum(BASELINE_DESIGN.values()))

# 评估标签（与你 Task 5 的智能启发式标签对齐）
EVALUATION_TAG = "B_T5_Smarter"

# ---------------------------------------------
# 工具函数
# ---------------------------------------------
def safe_replace_assign(src_code: str, var_name: str, new_value: str) -> str:
    pat = re.compile(rf"^{re.escape(var_name)}\s*=\s*.*$", re.MULTILINE)
    repl = f"{var_name} = {new_value}"
    return pat.sub(repl, src_code, count=1) if pat.search(src_code) else (src_code + f"\n{repl}\n")

def run_subprocess_live(cmd_list: List[str], cwd_path: Path) -> int:
    print(f"\n  Executing: {' '.join(map(str, cmd_list))}")
    print(f"  In Directory: {cwd_path}")
    # 建议可在此处加入 env["TQDM_DISABLE"]="1" 静默 Task 5 的 tqdm（如需）
    env = os.environ.copy()
    # env["TQDM_DISABLE"] = "1"
    proc = subprocess.Popen(
        cmd_list, cwd=cwd_path,
        stdout=subprocess.PIPE, stderr=subprocess.STDOUT,
        text=True, bufsize=1, env=env
    )
    for line in proc.stdout:
        sys.stdout.write(line)
    proc.wait()
    return proc.returncode

def clamp_design_total(design: Dict[str, int]) -> Dict[str, int]:
    """把总量限制在 CAP_TOTAL_LOCKERS 以内，优先压缩利用率最低的尺寸（调用处会传利用率排序）"""
    total = sum(design.values())
    if total <= CAP_TOTAL_LOCKERS:
        return design
    # 超限时，按 S->M->L 顺序减，或按调用方给的顺序自行减
    order = ['small', 'medium', 'large']
    overflow = total - CAP_TOTAL_LOCKERS
    for s in order:
        if overflow <= 0: break
        can_reduce = max(0, design[s] - MIN_LOCKERS_PER_SIZE)
        delta = min(can_reduce, overflow)
        design[s] -= delta
        overflow -= delta
    return design

# ---------------------------------------------
# Phase 1：首版定容（温和化）
# ---------------------------------------------
def generate_initial_design() -> Dict[str, int]:
    print("\n--- Phase 1: Generating Initial Optimized Design (tempered) ---")
    avg_demand = float(np.mean(list(SCENARIO_DEMANDS.values())))  # 五年场景均值
    parcels_in_peak_period = avg_demand * PEAK_4_WEEK_SHARE
    avg_parcels_per_week_peak = parcels_in_peak_period / 4.0
    peak_day_demand = avg_parcels_per_week_peak * PEAK_DAY_OF_WEEK_SHARE

    avg_duration_hours = 11.10
    arrival_rate_hourly = peak_day_demand / 24.0

    # 温和化：引入 ALPHA_OCCUPANCY 做经验缩放，避免一上来“炸数”
    avg_occupied_lockers = ALPHA_OCCUPANCY * arrival_rate_hourly * avg_duration_hours
    lam = max(1e-9, avg_occupied_lockers)
    total_lockers_needed = int(poisson.ppf(TARGET_SERVICE_LEVEL, lam))

    # 拆成 S/M/L，并加上最小保留
    num_s = max(int(round(total_lockers_needed * SPACE_REQUIREMENT_PROB['small'])),  MIN_LOCKERS_PER_SIZE)
    num_m = max(int(round(total_lockers_needed * SPACE_REQUIREMENT_PROB['medium'])), MIN_LOCKERS_PER_SIZE)
    num_l = max(int(total_lockers_needed - num_s - num_m), MIN_LOCKERS_PER_SIZE)

    initial = {'small': num_s, 'medium': num_m, 'large': num_l}
    # 总量硬上限
    initial = clamp_design_total(initial)

    print(f"  -> Initial design (tempered): {initial} (total={sum(initial.values())})")
    return initial

# ---------------------------------------------
# Phase 2：运行仿真并解析 KPI（与 Task 5 对齐）
# ---------------------------------------------
def run_and_analyze_design(design_config: Dict[str, int], iteration_tag: str) -> Optional[Dict[str, Any]]:
    print(f"\n--- Phase 2: Simulating & Analyzing Design for [{iteration_tag}] ---")
    run_dir = OUTPUT_DIR / f"run_{iteration_tag}"
    run_dir.mkdir(parents=True, exist_ok=True)
    temp_sim_script = run_dir / "_temp_simulator.py"

    if not SIMULATOR_SCRIPT_SRC.exists():
        print(f"FATAL: Simulator not found at {SIMULATOR_SCRIPT_SRC}")
        return None

    sim_code = SIMULATOR_SCRIPT_SRC.read_text(encoding="utf-8")
    sim_code = safe_replace_assign(sim_code, "OUT_DIR", f'r"{str(run_dir)}"')
    sim_code = safe_replace_assign(sim_code, "NUM_SMALL", str(design_config['small']))
    sim_code = safe_replace_assign(sim_code, "NUM_MEDIUM", str(design_config['medium']))
    sim_code = safe_replace_assign(sim_code, "NUM_LARGE", str(design_config['large']))
    sim_code = safe_replace_assign(sim_code, "simulations_to_run", f"[('{EVALUATION_TAG}', 't5_smarter')]")

    temp_sim_script.write_text(sim_code, encoding="utf-8")
    try:
        rc = run_subprocess_live([sys.executable, str(temp_sim_script)], cwd_path=BASE_DIR)
        if rc != 0:
            print(f"  -> ERROR: simulator exit {rc}")
            return None

        summary = run_dir / f"{EVALUATION_TAG}_summary.txt"
        results = run_dir / f"{EVALUATION_TAG}_results.csv"
        if not summary.exists() or not results.exists():
            cand_sum = sorted(run_dir.glob("*_summary.txt"))
            cand_res = sorted(run_dir.glob("*_results.csv"))
            if cand_sum and cand_res:
                summary, results = cand_sum[0], cand_res[0]
                print(f"  -> Fallback using: {summary.name}, {results.name}")
            else:
                print("  -> ERROR: Cannot find simulator outputs.")
                return None

        t = summary.read_text(encoding="utf-8")
        kv: Dict[str, Any] = {}
        def grab(pattern, cast):
            m = re.search(pattern, t)
            return cast(m.group(1)) if m else None

        kv['overall_sl']    = (grab(r"Overall Service Level:\s*([\d\.]+)%", float) or 0.0) / 100.0
        kv['min_daily_sl']  = (grab(r"Minimum Daily SL:\s*([\d\.]+)%", float) or 0.0) / 100.0
        kv['breach_days']   = int(grab(r"Days Breaching SLA Target:\s*(\d+)", int) or 0)
        kv['total_revenue'] = float((grab(r"Total Revenue:\s*\$([\d,\.]+)", str) or "0").replace(",", ""))
        kv['total_ergo_cost']= float((grab(r"Total Ergonomic Cost:\s*([\d,\.]+)", str) or "0").replace(",", ""))

        df = pd.read_csv(results)
        if 'status' in df.columns:
            rej = df[df['status'].eq('rejected')]
            kv['rejection_profile'] = rej['required_size'].value_counts().to_dict() if 'required_size' in rej.columns else {}
        else:
            kv['rejection_profile'] = {}

        # --- 体积利用率（与 Task5 保持一致口径） ---
        util = {'small': 0.0, 'medium': 0.0, 'large': 0.0}
        if {'assigned_locker_size', 'package_volume_ft3'}.issubset(df.columns):
            df_ok = df[df['status'] == 'accepted'].copy()
            if not df_ok.empty:
                df_ok['assigned_locker_capacity_ft3'] = df_ok['assigned_locker_size'].map(LOCKER_CAPACITY_FT3)
                for size in ['small', 'medium', 'large']:
                    group = df_ok[df_ok['assigned_locker_size'] == size]
                    if not group.empty:
                        vol = group['package_volume_ft3'].sum()
                        cap = group['assigned_locker_capacity_ft3'].sum()
                        util[size] = (vol / cap) if cap > 0 else 0.0
        kv['utilization_profile'] = util
        kv['utilization_mean']    = float(np.mean(list(util.values()))) if util else 0.0

        print(f"  -> SL={kv['overall_sl']:.3%}, minSL={kv['min_daily_sl']:.3%}, util_avg={kv['utilization_mean']:.2%}, revenue=${kv['total_revenue']:,.2f}")
        return kv
    finally:
        if temp_sim_script.exists():
            temp_sim_script.unlink()

# ---------------------------------------------
# Phase 3：提出下一版设计（带步长与上限控制）
# ---------------------------------------------
def propose_next_design(current: Dict[str,int], kpis: Dict[str,Any]) -> Dict[str,int]:
    print("\n--- Phase 3: Proposing Next Design (gated steps) ---")
    new_d = current.copy()
    sl   = float(kpis.get('overall_sl', 0.0))
    rej  = pd.Series(kpis.get('rejection_profile', {})).reindex(['small','medium','large'], fill_value=0)
    util = pd.Series(kpis.get('utilization_profile', {})).reindex(['small','medium','large'], fill_value=0.0)

    print(f"  -> Diagnostics: SL={sl:.3%}, Rejections={rej.to_dict()}, Utilization={ {k: f'{v:.2%}' for k,v in util.items()} }")

    step_budget = MAX_STEP_PER_ITER  # 本轮最多净变动柜数

    if sl < TARGET_SERVICE_LEVEL:
        # 未达标：对拒单最多的尺寸加柜，优先“交换”空闲尺寸（低利用）→ 若不够再纯加
        size_need = rej.idxmax() if not rej.empty else 'small'
        # 尝试交换（-1低利用 +1瓶颈），直到用完步长或达不到交换条件
        while step_budget > 0:
            # 找到非瓶颈中利用率最低的候选
            pool = util.drop(labels=[size_need])
            if not pool.empty and pool.min() < UTIL_SWAP_THRESHOLD:
                cand = pool.idxmin()
                if new_d[cand] > MIN_LOCKERS_PER_SIZE:
                    new_d[cand] -= 1
                    new_d[size_need] += 1
                    step_budget -= 1
                    print(f"  -> Swap: -1 {cand}, +1 {size_need}")
                    continue
            break

        # 若还有步长剩余，且总量未超上限，则直接为瓶颈尺寸加柜
        if step_budget > 0:
            addable = min(step_budget, CAP_TOTAL_LOCKERS - sum(new_d.values()))
            if addable > 0:
                new_d[size_need] += addable
                print(f"  -> Add: +{addable} {size_need}")
    else:
        # 已达标：尝试减掉“平均利用率最低”的尺寸各 1 个，受步长/最小保留约束
        order = list(util.sort_values(ascending=True).index)  # 低→高
        for cand in order:
            if step_budget <= 0:
                break
            if new_d[cand] > MIN_LOCKERS_PER_SIZE:
                new_d[cand] -= 1
                step_budget -= 1
                print(f"  -> Reduce: -1 {cand} (cost optimization)")

    # 确保不越过总量上限
    new_d = clamp_design_total(new_d)
    return new_d

# ---------------------------------------------
# 停止条件判定
# ---------------------------------------------
def should_stop(history: List[Dict[str, Any]], current_kpis: Dict[str,Any], current_design: Dict[str,int]) -> bool:
    """满足任一条件则停止"""
    sl_ok     = current_kpis.get('overall_sl', 0.0) >= TARGET_SERVICE_LEVEL
    minsl_ok  = current_kpis.get('min_daily_sl', 0.0) >= MIN_DAILY_SL_FLOOR
    util_ok   = current_kpis.get('utilization_mean', 0.0) >= MIN_UTILIZATION_MEAN

    # 与上一轮比较收益边际
    revenue_improve_ok = True
    if len(history) >= 1:
        last_rev = history[-1]['kpis'].get('total_revenue', 0.0)
        now_rev  = current_kpis.get('total_revenue', 0.0)
        revenue_improve_ok = (now_rev - last_rev) < REVENUE_IMPROVE_EPS

    # 设计不变（重复）直接停
    same_as_last = (len(history) >= 1 and history[-1]['design'] == current_design)

    # 综合判定：
    if same_as_last:
        print("  -> Stop: design unchanged from last iteration.")
        return True
    if sl_ok and minsl_ok and util_ok and revenue_improve_ok:
        print("  -> Stop: SLA met and marginal improvement negligible, utilization acceptable.")
        return True
    return False

# ---------------------------------------------
# 选优：在历史中挑推荐解
# ---------------------------------------------
def choose_best(history: List[Dict[str, Any]], baseline_kpis: Dict[str,Any], baseline_design: Dict[str,int]):
    if not history:
        return baseline_design, baseline_kpis, "baseline (no history)"
    feasible = [h for h in history if h['kpis'].get('overall_sl',0) >= TARGET_SERVICE_LEVEL]
    if feasible:
        best = max(feasible, key=lambda x: x['kpis'].get('total_revenue',0))
        chosen_label = f"iter_{best['iteration']}"
    else:
        best = max(history, key=lambda x: x['kpis'].get('overall_sl',0))
        chosen_label = f"iter_{best['iteration']} (highest SL)"
    return best['design'], best['kpis'], chosen_label

# ---------------------------------------------
# 主流程
# ---------------------------------------------
def main():
    if not SIMULATOR_SCRIPT_SRC.exists():
        print(f"FATAL: Simulator script '{SIMULATOR_SCRIPT_SRC}' not found.")
        return

    print("\n" + "="*60)
    print("--- STEP 1: Evaluating Baseline Design ---")
    print("="*60)
    baseline_kpis = run_and_analyze_design(BASELINE_DESIGN, "baseline")
    if not baseline_kpis:
        print("Baseline simulation failed.")
        return

    print("\n" + "="*60)
    print("--- STEP 2: Heuristic Iteration Loop ---")
    print("="*60)
    current = generate_initial_design()
    history: List[Dict[str, Any]] = []

    for i in range(1, MAX_ITERATIONS + 1):
        print(f"\n---------- Iteration {i}/{MAX_ITERATIONS} ----------")
        kpis = run_and_analyze_design(current, f"iter_{i}")
        if not kpis:
            print("  -> Simulation failed in iteration; break.")
            break

        # 记录历史
        history.append({'iteration': i, 'design': current.copy(), 'kpis': kpis})

        # 是否应停止
        if should_stop(history[:-1], kpis, current):
            print("\nDesign converged / stopping criteria met.")
            break

        # 产生下一版设计
        next_d = propose_next_design(current, kpis)

        # 若没有变化也停
        if next_d == current:
            print("\nDesign converged (no further change).")
            break

        current = next_d
        time.sleep(0.2)  # 小憩以便读日志

    print("\n" + "="*60)
    print("--- STEP 3: Best Design & Final Report ---")
    print("="*60)
    recommended_design, recommended_kpis, chosen_label = choose_best(history, baseline_kpis, BASELINE_DESIGN)

    final_counts = {
        "small": int(recommended_design['small']),
        "medium": int(recommended_design['medium']),
        "large": int(recommended_design['large']),
        "total": int(sum(recommended_design.values())),
        "chosen_from": chosen_label
    }
    print("\n✅ FINAL RECOMMENDED LOCKER COUNTS")
    print(f"   small = {final_counts['small']}")
    print(f"   medium = {final_counts['medium']}")
    print(f"   large = {final_counts['large']}")
    print(f"   total = {final_counts['total']}  (chosen: {final_counts['chosen_from']})")

    # 导出
    counts_csv  = OUTPUT_DIR / "final_recommended_design_counts.csv"
    counts_json = OUTPUT_DIR / "final_recommended_design_counts.json"
    pd.DataFrame([final_counts]).to_csv(counts_csv, index=False)
    counts_json.write_text(json.dumps(final_counts, indent=2), encoding="utf-8")
    print(f"   -> Saved counts CSV: {counts_csv}")
    print(f"   -> Saved counts JSON: {counts_json}")

    # 对比摘要
    summary_df = pd.DataFrame({
        "Metric": ["", "Config: Small", "Config: Medium", "Config: Large", "Config: Total Lockers",
                   "", "Overall Service Level", "Min Daily SL", "SLA Breach Days",
                   "", "Total Revenue", "Total Ergonomic Cost", "Avg Volume Utilization"],
        "Baseline Design": [
            "", BASELINE_DESIGN['small'], BASELINE_DESIGN['medium'], BASELINE_DESIGN['large'], sum(BASELINE_DESIGN.values()),
            "", f"{baseline_kpis.get('overall_sl',0):.3%}", f"{baseline_kpis.get('min_daily_sl',0):.3%}", f"{baseline_kpis.get('breach_days',0)}",
            "", f"${baseline_kpis.get('total_revenue',0):,.2f}", f"{baseline_kpis.get('total_ergo_cost',0):,.2f}", "-"
        ],
        "Recommended Design (Task 7)": [
            "", final_counts['small'], final_counts['medium'], final_counts['large'], final_counts['total'],
            "", f"{recommended_kpis.get('overall_sl',0):.3%}", f"{recommended_kpis.get('min_daily_sl',0):.3%}", f"{recommended_kpis.get('breach_days',0)}",
            "", f"${recommended_kpis.get('total_revenue',0):,.2f}", f"{recommended_kpis.get('total_ergo_cost',0):,.2f}", f"{recommended_kpis.get('utilization_mean',0):.2%}"
        ]
    })
    final_summary_path = OUTPUT_DIR / "final_comparison_summary.csv"
    print("\n" + "="*60)
    print("--- FINAL PERFORMANCE COMPARISON ---")
    print(summary_df.to_string(index=False))
    print("="*60)
    summary_df.to_csv(final_summary_path, index=False)
    print(f"\n✅ Final summary saved to '{final_summary_path}'")
    print(f"✅ All artifacts saved in '{OUTPUT_DIR}'")

if __name__ == "__main__":
    main()
