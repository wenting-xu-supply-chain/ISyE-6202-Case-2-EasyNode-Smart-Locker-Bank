# -*- coding: utf-8 -*-
"""
Task 5 - Locker Bank Operation Simulator (Integrated with Task 4 Heuristics)
Author: (your name)
Last Update: 2025-10-14

功能：
- 集成 Task 4 的启发式：
  - strawman (先到先分)
  - smarter (服务水平最大化: 尺寸匹配 + 稀缺保护 + 人体工学)
- 运行 Task 5 的运营仿真，输出 KPI、CSV 与可视化图

*** 版本说明：此版本集成了以服务水平为导向的 "smarter" 决策算法 ***
"""

import os, json, math, warnings
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from tqdm import tqdm
from collections import defaultdict

warnings.filterwarnings("ignore", category=pd.errors.SettingWithCopyWarning)

# =========================
# 全局参数（可按需调整）
# =========================
# ——输入/输出——
INPUT_DEMAND_CSV = "task3_demand_instance_two_level_cv.csv"
OUT_DIR = "Task_5_Outcome_ServiceLevel_Max" # MODIFIED: New output directory
os.makedirs(OUT_DIR, exist_ok=True)

# ——柜体网格参数——
GRID_HEIGHT = 15
ROW_HEIGHT_CM = 10
BASE_FLOOR_TO_ROW0_CM = 30

# ——尺寸映射（单位格数）——
SIZE_UNITS = {'small': 1, 'medium': 2, 'large': 3}

# ——人体工学——
USER_HEIGHT_DIST_CM = {'p05': 155, 'p50': 170, 'p95': 185}
ARM_REACH_OFFSET_CM = 70
REACH_SAFETY_MARGIN_CM = 10

# ——政策与定价 (for reporting purposes only)——
POLICY_EARLY_ARRIVE_MAX_MIN = 90
POLICY_LATE_PICKUP_MAX_H = 180
BASE_FEE = 5.0
SIZE_UPCHARGE = {'small': 0.0, 'medium': 1.5, 'large': 3.0}
LATE_FEE_STEP = 0.20

# ——随机性与复现——
RANDOM_SEED = 20251014
np.random.seed(RANDOM_SEED)

# ——基线柜体配置——
NUM_SMALL = 40
NUM_MEDIUM = 71
NUM_LARGE = 41

# ——SLA 目标（逐日）——
SLA_DAILY_TARGET = 0.995

# ——仿真设置——
WARMUP_DAYS = 2.0
REPLICATIONS = 1

# =========================
# 工具函数、数据结构、Agent类
# =========================
def row_to_height_cm(row_idx: int) -> float: return BASE_FLOOR_TO_ROW0_CM + row_idx * ROW_HEIGHT_CM
def sample_user_height_cm() -> float:
    r = np.random.rand()
    if r < 0.2: return np.random.normal(USER_HEIGHT_DIST_CM['p05'], 2.5)
    elif r < 0.8: return np.random.normal(USER_HEIGHT_DIST_CM['p50'], 3.0)
    else: return np.random.normal(USER_HEIGHT_DIST_CM['p95'], 2.5)
def reachable_row_range_for_user() -> tuple[int, int]:
    h = sample_user_height_cm()
    reach_max_cm = h + ARM_REACH_OFFSET_CM - REACH_SAFETY_MARGIN_CM
    reach_min_cm = max(0, h * 0.35)
    max_row = min(GRID_HEIGHT - 1, int(round((reach_max_cm - BASE_FLOOR_TO_ROW0_CM) / ROW_HEIGHT_CM)))
    min_row = max(0, int(round((reach_min_cm - BASE_FLOOR_TO_ROW0_CM) / ROW_HEIGHT_CM)))
    return (min_row, max_row) if min_row <= max_row else (0, GRID_HEIGHT - 1)
def ceil_int(x): return int(math.ceil(float(x)))
def ensure_int_ft3(val, lo=1, hi=18):
    if pd.isna(val): return lo
    return max(lo, min(hi, ceil_int(val)))

class Locker:
    def __init__(self, locker_id, size_category, position_rc):
        self.id = locker_id; self.size = size_category; self.position = position_rc; self.schedule = []
    def is_available(self, start, end):
        for s, e in self.schedule:
            if start < e and end > s: return False
        return True
    def book(self, start, end):
        self.schedule.append((start, end)); self.schedule.sort(key=lambda x: x[0])

class LockerBank:
    def __init__(self, num_s, num_m, num_l, height=GRID_HEIGHT):
        self.height = height; self.lockers = []
        self._create_layout(num_s, num_m, num_l)
        # MODIFIED: Store total counts for availability calculation
        self.total_by_size = self.count_by_size()

    def _create_layout(self, num_s, num_m, num_l):
        specs = [('small', num_s), ('medium', num_m), ('large', num_l)]
        current_row, current_col, lid = 0, 0, 0
        for size, cnt in specs:
            h_units = SIZE_UNITS[size]
            for _ in range(cnt):
                if current_row + h_units > self.height: current_row, current_col = 0, current_col + 1
                center_row = current_row + (h_units -1) / 2 # Use center for ergonomics
                self.lockers.append(Locker(lid, size, (center_row, current_col)))
                current_row += h_units; lid += 1
                
    def count_by_size(self):
        c = defaultdict(int)
        for L in self.lockers: c[L.size] += 1
        return dict(c)

    def total_lockers(self): return len(self.lockers)
    
    # NEW: Method from Task 4 to get real-time availability
    def get_availability_ratios(self, at_time):
        available_counts = self.count_by_size()
        for l in self.lockers:
            if not l.is_available(at_time, at_time + pd.Timedelta(seconds=1)):
                available_counts[l.size] -= 1
        ratios = {size: (available_counts.get(size, 0) / total if total > 0 else 0) for size, total in self.total_by_size.items()}
        return ratios

class AssignmentAgent:
    def __init__(self, locker_bank: LockerBank):
        self.lb = locker_bank
        self.base_fee = BASE_FEE; self.size_upcharge = SIZE_UPCHARGE

    @staticmethod
    def _size_value(cat): return SIZE_UNITS[cat]
    def _user_reachable(self, locker: Locker, reachable_range): rmin, rmax = reachable_range; return rmin <= locker.position[0] <= rmax
    
    def _get_candidates(self, req_cat, reachable_range):
        req_v = self._size_value(req_cat)
        feas = [L for L in self.lb.lockers if self._size_value(L.size) >= req_v and self._user_reachable(L, reachable_range)]
        # Sort by size fit first, then by ergonomics (center-out)
        feas.sort(key=lambda L: (self._size_value(L.size) - req_v, abs(L.position[0] - GRID_HEIGHT//2)))
        return feas

    # NEW: Service-level driven scoring function from Task 4
    def _smarter_score_service_level(self, locker: Locker, req_cat: str, availability_ratios: dict) -> float:
        # 1. Size Fit Score (Weight: 0.5)
        size_diff = self._size_value(locker.size) - self._size_value(req_cat)
        size_fit_score = math.exp(-2 * size_diff)

        # 2. Scarcity Protection Score (Weight: 0.3)
        scarcity_score = availability_ratios.get(locker.size, 0)

        # 3. Ergonomics Score (Weight: 0.2)
        ergo_score = 1.0 - (abs(locker.position[0] - self.lb.height / 2) / (self.lb.height / 2))

        # Final Weighted Score
        return (0.5 * size_fit_score) + (0.3 * scarcity_score) + (0.2 * ergo_score)
        
    def _apply_policy_and_price(self, desired_start, desired_end, assigned_size, req_size):
        rs = max(desired_start - pd.Timedelta(minutes=POLICY_EARLY_ARRIVE_MAX_MIN), desired_start.floor('h'))
        re = min(desired_end + pd.Timedelta(hours=POLICY_LATE_PICKUP_MAX_H), desired_end.ceil('h'))
        base, upc = self.base_fee, self.size_upcharge.get(assigned_size, 0.0)
        planned, actual = (desired_end - desired_start).total_seconds(), (re - rs).total_seconds()
        late_fee = 0.0
        if planned > 0 and actual > planned: late_fee = int(math.ceil((actual - planned)/planned / LATE_FEE_STEP)) * LATE_FEE_STEP * base
        return rs, re, base, upc, late_fee

    def assign_strawman(self, req_cat, start, end, rr):
        for L in self._get_candidates(req_cat, rr):
            if L.is_available(start, end): return L
        return None

    # MODIFIED: Smarter assignment now uses the new service-level score
    def assign_smarter(self, req_cat, start, end, rr):
        cands = [L for L in self._get_candidates(req_cat, rr) if L.is_available(start, end)]
        if not cands: return None
        
        availability_ratios = self.lb.get_availability_ratios(at_time=start)
        
        return max(cands, key=lambda L: self._smarter_score_service_level(L, req_cat, availability_ratios))

# --- KPI Calculation and Plotting Functions (Unchanged) ---
def compute_daily_service_level(df_result: pd.DataFrame):
    g = df_result.groupby('date').agg(reqs=('package_id','count'), acc=('status', lambda s: (s=='accepted').sum())).reset_index()
    g['service_level'] = g['acc'] / g['reqs']
    return g
def compute_hourly_utilization(df_result: pd.DataFrame, total_lockers: int):
    acc = df_result[df_result['status']=='accepted'].copy()
    if acc.empty: return pd.DataFrame({'hour': range(24), 'utilization': [0.0]*24})
    occ = defaultdict(int)
    for _, r in acc.iterrows():
        t = pd.to_datetime(r['real_start']).floor('h')
        end = pd.to_datetime(r['real_end'])
        while t < end: occ[t] += 1; t += pd.Timedelta(hours=1)
    df = pd.DataFrame({'ts': list(occ.keys()), 'occupied': list(occ.values())})
    df['hour'] = pd.to_datetime(df['ts']).dt.hour
    hourly = df.groupby('hour')['occupied'].mean().reset_index()
    hourly['utilization'] = hourly['occupied'] / max(1, total_lockers)
    return pd.DataFrame({'hour': range(24)}).merge(hourly[['hour','utilization']], on='hour', how='left').fillna(0.0)
def compute_revenue_breakdown(df_result: pd.DataFrame):
    acc = df_result[df_result['status']=='accepted']
    tot = acc[['revenue_base','revenue_size_upcharge','revenue_late_fee']].sum()
    return pd.DataFrame({'component': ['base','size_up','late_fee'],
                         'revenue': [float(tot.get('revenue_base',0.0)), float(tot.get('revenue_size_upcharge',0.0)), float(tot.get('revenue_late_fee',0.0))]})
def plot_daily_service_level(daily_df, path):
    plt.figure(figsize=(11,4)); plt.plot(pd.to_datetime(daily_df['date']), daily_df['service_level'])
    plt.axhline(SLA_DAILY_TARGET, color='r', linestyle='--', label=f'{SLA_DAILY_TARGET:.1%} Target')
    plt.title('Daily Service Level'); plt.xlabel('Date'); plt.ylabel('Service Level')
    plt.legend(); plt.tight_layout(); plt.savefig(path, dpi=160); plt.close()
def plot_hourly_utilization(hourly_df, path):
    plt.figure(figsize=(8,4)); plt.bar(hourly_df['hour'], hourly_df['utilization'])
    plt.title('Average Utilization by Hour of Day'); plt.xlabel('Hour'); plt.ylabel('Utilization')
    plt.xticks(range(0,24,2)); plt.tight_layout(); plt.savefig(path, dpi=160); plt.close()
def plot_revenue_breakdown(rev_df, path):
    plt.figure(figsize=(6,4)); plt.bar(rev_df['component'], rev_df['revenue'])
    plt.title('Revenue Breakdown (Reporting Only)'); plt.xlabel('Component'); plt.ylabel('Revenue')
    plt.tight_layout(); plt.savefig(path, dpi=160); plt.close()

class LockerBankSimulator:
    def __init__(self, locker_bank: LockerBank, demand_df: pd.DataFrame, agent: AssignmentAgent, heuristic='smarter', warmup_days=WARMUP_DAYS):
        self.lb = locker_bank; self.demand = demand_df.copy(); self.agent = agent; self.heuristic = heuristic
        self.warmup_days = warmup_days; self.results = pd.DataFrame()
    def _req_category(self, v_ft3):
        v = ensure_int_ft3(v_ft3)
        if 1 <= v <= 3: return 'small'
        elif 4 <= v <= 9: return 'medium'
        else: return 'large'
    def run(self):
        if self.demand.empty: print("No demand!"); return
        start_ts = self.demand['real_deposit_dt'].min(); warmup_cut = start_ts + pd.Timedelta(days=self.warmup_days)
        
        demand_array = self.demand[['package_id', 'min_size_ft3', 'real_deposit_dt', 'real_pickup_dt']].to_numpy()
        rows = []
        
        for r_data in tqdm(demand_array, total=len(demand_array), desc=f"Simulating ({self.heuristic})", ncols=90):
            pkg, min_size_ft3, start_dt, end_dt = r_data
            start, end = pd.to_datetime(start_dt), pd.to_datetime(end_dt)
            req_cat = self._req_category(min_size_ft3)
            rr = reachable_row_range_for_user()
            
            # The core decision logic is now inside the agent's method
            chosen = self.agent.assign_strawman(req_cat, start, end, rr) if self.heuristic == 'strawman' else self.agent.assign_smarter(req_cat, start, end, rr)
            
            row = {'package_id': pkg, 'required_size': req_cat, 'status': 'rejected', 'reason': '', 'assigned_locker_id': None, 'assigned_locker_size': None,
                   'desired_start': start, 'desired_end': end, 'real_start': pd.NaT, 'real_end': pd.NaT, 'revenue_base': 0.0,
                   'revenue_size_upcharge': 0.0, 'revenue_late_fee': 0.0, 'date': start.date(), 'hour': start.hour,
                   'keep_for_eval': start >= warmup_cut}
            
            if chosen is None:
                row['reason'] = 'rejected_full' if len(self.agent._get_candidates(req_cat, rr)) > 0 else 'rejected_unreachable'
            else:
                rs, re, base, upc, late = self.agent._apply_policy_and_price(start, end, chosen.size, req_cat)
                chosen.book(rs, re)
                row.update({'status': 'accepted', 'reason': 'accepted_exact' if chosen.size == req_cat else 'accepted_oversize',
                            'assigned_locker_id': chosen.id, 'assigned_locker_size': chosen.size, 'real_start': rs, 'real_end': re,
                            'revenue_base': base, 'revenue_size_upcharge': upc, 'revenue_late_fee': late})
            rows.append(row)
            
        self.results = pd.DataFrame(rows)
        
    def summarize(self, tag: str):
        if self.results.empty: print("No results to summarize."); return None
        eval_df = self.results[self.results['keep_for_eval']].copy()
        if eval_df.empty: print(f"[{tag}] No data left after warmup period."); return None
        
        daily = compute_daily_service_level(eval_df)
        min_daily_sla = daily['service_level'].min()
        breach_days = int((daily['service_level'] < SLA_DAILY_TARGET).sum())
        hourly = compute_hourly_utilization(eval_df, self.lb.total_lockers())
        rev = compute_revenue_breakdown(eval_df)
        total_revenue = rev['revenue'].sum()
        overall_sl = (eval_df['status']=='accepted').mean()
        
        print(f"\n--- {tag} Summary ---")
        print(f"Overall SL: {overall_sl:.2%} | Min Daily SL: {min_daily_sla:.2%} | Breach Days (below {SLA_DAILY_TARGET:.1%}): {breach_days}")
        print(f"Total Revenue: {total_revenue:,.2f} {tuple(rev['revenue'].round(2))}")
        
        prefix = 'A_' if tag.lower().startswith('straw') else 'B_'
        eval_df.to_csv(os.path.join(OUT_DIR, f"{prefix}results_eval.csv"), index=False)
        plot_daily_service_level(daily, os.path.join(OUT_DIR, f"{prefix}daily_service_level.png"))
        plot_hourly_utilization(hourly, os.path.join(OUT_DIR, f"{prefix}hourly_utilization.png"))
        plot_revenue_breakdown(rev, os.path.join(OUT_DIR, f"{prefix}revenue_breakdown.png"))
        
        return {'overall_sl': overall_sl, 'min_daily_sla': min_daily_sla, 'breach_days': breach_days, 'total_revenue': float(total_revenue)}

# =========================
# 主程序
# =========================
def main():
    if not os.path.exists(INPUT_DEMAND_CSV):
        raise FileNotFoundError(f"未找到 Task 3 产出文件：{INPUT_DEMAND_CSV}")

    demand_df = pd.read_csv(INPUT_DEMAND_CSV, parse_dates=['real_deposit_dt','real_pickup_dt'])
    print(f"Loaded full 5-year demand data with {len(demand_df):,} records.")
    
    bank1 = LockerBank(NUM_SMALL, NUM_MEDIUM, NUM_LARGE, height=GRID_HEIGHT)
    bank2 = LockerBank(NUM_SMALL, NUM_MEDIUM, NUM_LARGE, height=GRID_HEIGHT)

    agent_straw = AssignmentAgent(bank1)
    agent_smart = AssignmentAgent(bank2)

    sim_a = LockerBankSimulator(bank1, demand_df, agent_straw, heuristic='strawman')
    sim_a.run()
    sim_a.summarize(tag='Strawman')

    sim_b = LockerBankSimulator(bank2, demand_df, agent_smart, heuristic='smarter')
    sim_b.run()
    sim_b.summarize(tag='Smarter (Service-Level Max)')

    params = {
        'smarter_heuristic_objective': 'Maximize Service Level',
        'smarter_scoring_weights': {'size_fit': 0.5, 'scarcity_protection': 0.3, 'ergonomics': 0.2},
        'num_small': NUM_SMALL, 'num_medium': NUM_MEDIUM, 'num_large': NUM_LARGE,
        'random_seed': RANDOM_SEED, 'sla_daily_target': SLA_DAILY_TARGET,
        'warmup_days': WARMUP_DAYS, 'replications': REPLICATIONS,
        'policy': {'early_arrive_max_min': POLICY_EARLY_ARRIVE_MAX_MIN, 'late_pickup_max_h': POLICY_LATE_PICKUP_MAX_H,
                   'base_fee': BASE_FEE, 'size_upcharge': SIZE_UPCHARGE, 'late_fee_step': LATE_FEE_STEP},
    }
    with open(os.path.join(OUT_DIR, 'task5_params.json'), 'w', encoding='utf-8') as f:
        json.dump(params, f, indent=2, ensure_ascii=False)

    with open(os.path.join(OUT_DIR, 'README_Task5.txt'), 'w', encoding='utf-8') as f:
        f.write("""
Task 5 Integrated Simulation (Service-Level Maximization)
=========================================================

This directory contains the simulation results for Task 5, where the 'Smarter'
heuristic is specifically designed to maximize the long-term service level.

Key Heuristic Logic:
- The 'Smarter' agent makes decisions by scoring potential lockers based on a
  weighted combination of:
  1. Size Fit (50%): Prioritizes using the smallest possible locker to free up
     larger ones for future demand.
  2. Scarcity Protection (30%): Avoids using a locker type that is currently
     in low supply.
  3. Ergonomics (20%): A minor preference for user comfort.
- Note: The policy-based revenue is calculated and reported but does NOT
  influence the Smarter agent's assignment decisions.

Key Files:
- A_... files correspond to the 'Strawman' heuristic.
- B_... files correspond to the 'Smarter (Service-Level Max)' heuristic.
- The .csv files contain the raw data for results, daily SL, etc.
- The .png files are the corresponding visualizations.
- task5_params.json: The parameters used for this simulation run.
""")

    print(f"\n✅ 所有结果已输出至目录：{OUT_DIR}")

if __name__ == '__main__':
    main()
