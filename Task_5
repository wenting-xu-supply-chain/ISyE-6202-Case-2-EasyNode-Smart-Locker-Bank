# -*- coding: utf-8 -*-
"""
Task 5 - Locker Bank Operation Simulator (Directly Integrated with Task 4 Heuristics)
Author: (your name)
Last Update: 2025-10-15

功能：
- 运行 Task 5 原有的 strawman 和 smarter 启发式。
- *** 新增: 直接嵌入了 Task 4 的 strawman 和 cost-minimization (smarter) 启发式作为对比。***
- *** 优化: 采用了性能更优的 Locker 类（bisect 查找）。***
- *** 性能升级: 采用多核并行计算，并为每个并行任务提供独立的进度条。***
- *** 指标增强: 在总结报告中增加了储物柜利用率（Utilization）指标。***
"""

import os, json, math, warnings, bisect, time
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from tqdm import tqdm
from collections import defaultdict
from joblib import Parallel, delayed

warnings.filterwarnings("ignore", category=pd.errors.SettingWithCopyWarning)

# =========================
# 全局参数（保持 Task 5 原有结构）
# =========================
INPUT_DEMAND_CSV = "Task_3_Outcome/task3_demand_instance_highest_mode.csv"
OUT_DIR = "Task_5_Outcome"
os.makedirs(OUT_DIR, exist_ok=True)

# ... (所有其他参数保持不变) ...
GRID_HEIGHT = 15
ROW_HEIGHT_CM = 10
BASE_FLOOR_TO_ROW0_CM = 30
SIZE_UNITS = {'small': 1, 'medium': 2, 'large': 3}
USER_HEIGHT_DIST_CM = {'p05': 155, 'p50': 170, 'p95': 185}
ARM_REACH_OFFSET_CM = 70
REACH_SAFETY_MARGIN_CM = 10
POLICY_EARLY_ARRIVE_MAX_MIN = 90
POLICY_LATE_PICKUP_MAX_H = 180
BASE_FEE = 5.0
SIZE_UPCHARGE = {'small': 0.0, 'medium': 1.5, 'large': 3.0}
LATE_FEE_STEP = 0.20
LOOKAHEAD_HOURS = 48
SIZE_PROTECTION_LARGE_THRESHOLD = 0.15
RANDOM_SEED = 20251010
np.random.seed(RANDOM_SEED)
NUM_SMALL = 44
NUM_MEDIUM = 51
NUM_LARGE = 30
SLA_DAILY_TARGET = 0.995
WARMUP_DAYS = 2.0
OVERSIZE_OPPORTUNITY_COST_PER_LEVEL = 4.0

# =========================
# 工具函数与数据结构 (这部分完全不变)
# =========================
def get_ergonomic_cost(req_size_cat, assigned_size_cat, y_pos):
    y = y_pos + 1; cost = 0.0; size_map = {'small': 1, 'medium': 2, 'large': 3}
    d_req, d_assigned = size_map.get(req_size_cat), size_map.get(assigned_size_cat)
    if d_req is None or d_assigned is None or d_assigned < d_req: return float('inf')
    if d_req == 1 and d_assigned == 1:   cost = 0.01 * (115 - 15*y) if y <= 7 else 0.01 * (-95 + 15*y)
    elif d_req == 1 and d_assigned == 2: cost = 0.01 * ((75 + (65/6)) - (65/6)*y) if y <= 7 else 0.01 * (10 - 7*(65/6) + (65/6)*y)
    elif d_req == 1 and d_assigned == 3: cost = 0.01 * ((50 + (40/6)) - (40/6)*y) if y <= 7 else 0.01 * (10 - 7*(40/6) + (40/6)*y)
    elif d_req == 2 and d_assigned == 2: cost = 0.01 * ((10 - (65/14)) + (65/14)*y)
    elif d_req == 2 and d_assigned == 3: cost = 0.01 * ((10 - (90/14)) + (90/14)*y)
    elif d_req == 3 and d_assigned == 3: cost = 0.01 * ((10 - (90/14)) + (90/14)*y)
    return max(0, cost)

def reachable_row_range_for_user():
    h = np.random.normal(USER_HEIGHT_DIST_CM['p50'], 3.0)
    reach_max_cm = h + ARM_REACH_OFFSET_CM - REACH_SAFETY_MARGIN_CM
    reach_min_cm = max(0, h * 0.35)
    max_row = min(GRID_HEIGHT - 1, int(round((reach_max_cm - BASE_FLOOR_TO_ROW0_CM) / ROW_HEIGHT_CM)))
    min_row = max(0, int(round((reach_min_cm - BASE_FLOOR_TO_ROW0_CM) / ROW_HEIGHT_CM)))
    return (min_row, max_row) if min_row <= max_row else (0, GRID_HEIGHT - 1)

class Locker:
    def __init__(self, locker_id, size_category, position_rc):
        self.id, self.size, self.position, self.schedule = locker_id, size_category, position_rc, []
    def is_available(self, start, end):
        if not self.schedule: return True
        idx = bisect.bisect_right(self.schedule, (start, start))
        if idx > 0 and self.schedule[idx - 1][1] > start: return False
        if idx < len(self.schedule) and self.schedule[idx][0] < end: return False
        return True
    def book(self, start, end): bisect.insort(self.schedule, (start, end))

class LockerBank:
    def __init__(self, num_s, num_m, num_l, height=GRID_HEIGHT):
        self.height = height; self.lockers = []
        self._create_layout(num_s, num_m, num_l)
    def _create_layout(self, num_s, num_m, num_l):
        specs = [('small', num_s), ('medium', num_m), ('large', num_l)]
        current_row, current_col, lid = 0, 0, 0
        for size, cnt in specs:
            h_units = SIZE_UNITS[size]
            for _ in range(cnt):
                if current_row + h_units > self.height: current_row, current_col = 0, current_col + 1
                center_row = current_row + (h_units - 1) / 2.0
                self.lockers.append(Locker(lid, size, (int(round(center_row)), current_col)))
                current_row += h_units; lid += 1
    def total_lockers(self): return len(self.lockers)

class AssignmentAgent:
    def __init__(self, locker_bank: LockerBank):
        self.lb = locker_bank; self._build_req_size_map()
        self.total_large = sum(1 for L in self.lb.lockers if L.size == 'large')
        self.booked_large_count = 0 # <-- 新增计数器
    def _build_req_size_map(self):
        m = {}; [m.update({s: 'small'}) for s in range(1, 4)]; [m.update({s: 'medium'}) for s in range(4, 10)]; [m.update({s: 'large'}) for s in range(10, 19)]
        self.req_size_map = m
    @staticmethod
    def _size_value(cat): return {'small': 1, 'medium': 2, 'large': 3}.get(cat, 0)
    def _get_candidates(self, req_cat, start, end, rr):
        req_v = self._size_value(req_cat)
        return [L for L in self.lb.lockers if self._size_value(L.size) >= req_v and (rr[0] <= L.position[0] <= rr[1]) and L.is_available(start, end)]
    def _apply_policy_and_price(self, desired_start, desired_end, assigned_size, req_size, locker_position_row=0):
        rs = max(desired_start - pd.Timedelta(minutes=POLICY_EARLY_ARRIVE_MAX_MIN), desired_start.floor('h'))
        re = min(desired_end + pd.Timedelta(hours=POLICY_LATE_PICKUP_MAX_H), desired_end.ceil('h'))
        base, upc = BASE_FEE, SIZE_UPCHARGE.get(assigned_size, 0.0)
        planned, actual = (desired_end - desired_start).total_seconds(), (re - rs).total_seconds()
        late_fee = 0.0
        if planned > 0 and actual > planned: late_fee = int(math.ceil((actual - planned)/planned / LATE_FEE_STEP)) * LATE_FEE_STEP * base
        return rs, re, base, upc, late_fee, get_ergonomic_cost(req_size, assigned_size, locker_position_row)
    def assign_t5_strawman(self, req_cat, start, end, rr):
        cands = self._get_candidates(req_cat, start, end, rr)
        cands.sort(key=lambda L: (self._size_value(L.size) - self._size_value(req_cat), L.position[1], abs(L.position[0] - GRID_HEIGHT//2)))
        return cands[0] if cands else None
    def assign_t5_smarter(self, req_cat, start, end, rr):
        cands = self._get_candidates(req_cat, start, end, rr)
        if not cands: return None
        
        # 在循环外计算一次大储物柜的占用情况
        num_large_used = sum(1 for L in self.lb.lockers if L.size == 'large' and L.schedule and L.schedule[-1][1] > start)
        large_remain_ratio = (self.total_large - num_large_used) / self.total_large
        
        # 将计算好的值传入 _smarter_score
        return max(cands, key=lambda L: self._smarter_score(L, req_cat, start, end, large_remain_ratio))
    def _smarter_score(self, locker: Locker, req_cat, start, end, large_remain_ratio):
        req_v, size_diff = self._size_value(req_cat), self._size_value(locker.size) - self._size_value(req_cat)
        size_score = 1.0 / (1 + 2.0 * max(0, size_diff))
        ergo_soft = 1.0 - min(1.0, abs(locker.position[0] - GRID_HEIGHT/2) / (GRID_HEIGHT/2)) * 0.6
        
        next_start = float('inf')
        # 使用 bisect 可以比线性扫描更快地找到下一个日程
        idx = bisect.bisect_right(locker.schedule, (end, end))
        if idx < len(locker.schedule):
            next_start = locker.schedule[idx][0]
        
        future = 1.0 if next_start == float('inf') else max(0.0, min(1.0, (next_start - end).total_seconds()/3600 / LOOKAHEAD_HOURS))
        
        protect_penalty = 0.0
        if locker.size == 'large' and size_diff > 0:
            # 直接使用传入的参数，不再重新计算
            if large_remain_ratio < SIZE_PROTECTION_LARGE_THRESHOLD:
                protect_penalty = (SIZE_PROTECTION_LARGE_THRESHOLD - large_remain_ratio) * 0.8
                
        return (0.40 * size_score) + (0.30 * ergo_soft) + (0.30 * future) - protect_penalty
    def assign_t4_strawman(self, req_cat, start, end, rr):
        candidates = self._get_candidates(req_cat, start, end, rr)
        if not candidates: return None
        candidates.sort(key=lambda l: (self._size_value(l.size), l.id))
        return candidates[0]
    def assign_t4_smarter_cost_min(self, req_cat, start, end, rr):
        candidates = self._get_candidates(req_cat, start, end, rr)
        if not candidates: return None
        best_locker, min_cost = None, float('inf')
        req_v = self._size_value(req_cat)
        for locker in candidates:
            ergo_cost = get_ergonomic_cost(req_cat, locker.size, locker.position[0])
            oversize_penalty = (self._size_value(locker.size) - req_v) * OVERSIZE_OPPORTUNITY_COST_PER_LEVEL
            total_cost = ergo_cost + oversize_penalty
            if total_cost < min_cost:
                best_locker, min_cost = locker, total_cost
        return best_locker

class LockerBankSimulator:
    def __init__(self, locker_bank: LockerBank, demand_df: pd.DataFrame, agent: AssignmentAgent, heuristic='smarter', warmup_days=WARMUP_DAYS, position=0):
        self.lb = locker_bank; self.demand = demand_df.copy(); self.agent = agent
        self.heuristic = heuristic; self.warmup_days = warmup_days
        self.results = pd.DataFrame()
        self.position = position 

    def _req_category(self, v_ft3):
        v = int(math.ceil(float(v_ft3))) if pd.notna(v_ft3) else 1
        return self.agent.req_size_map.get(max(1, min(18, v)), 'large')
    
    def run(self):
        start_ts = self.demand['real_deposit_dt'].min(); warmup_cut = start_ts + pd.Timedelta(days=self.warmup_days)
        demand_array = self.demand[['package_id', 'min_size_ft3', 'real_deposit_dt', 'real_pickup_dt']].to_numpy()
        rows = []
        
        progress_bar = tqdm(
            demand_array,
            desc=f"Sim ({self.heuristic})".ljust(30), 
            position=self.position, 
            ncols=100
        )
        
        for r_data in progress_bar:
            pkg, min_size_ft3, start_dt, end_dt = r_data
            start, end = pd.to_datetime(start_dt), pd.to_datetime(end_dt)
            req_cat = self._req_category(min_size_ft3)
            rr = reachable_row_range_for_user()
            
            chosen = None
            if self.heuristic == 't5_strawman': chosen = self.agent.assign_t5_strawman(req_cat, start, end, rr)
            elif self.heuristic == 't5_smarter': chosen = self.agent.assign_t5_smarter(req_cat, start, end, rr)
            elif self.heuristic == 't4_strawman': chosen = self.agent.assign_t4_strawman(req_cat, start, end, rr)
            elif self.heuristic == 't4_smarter_cost_min': chosen = self.agent.assign_t4_smarter_cost_min(req_cat, start, end, rr)

            row = {'package_id': pkg, 'required_size': req_cat, 'status': 'rejected', 'assigned_locker_size': None,
                   'real_start': pd.NaT, 'real_end': pd.NaT, 'revenue_base': 0.0,
                   'revenue_size_upcharge': 0.0, 'revenue_late_fee': 0.0, 'date': start.date(),
                   'keep_for_eval': start >= warmup_cut, 'ergonomic_cost': 0.0}
            if chosen:
                rs, re, base, upc, late, ergo_cost = self.agent._apply_policy_and_price(start, end, chosen.size, req_cat, chosen.position[0])
                chosen.book(rs, re)
                row.update({'status': 'accepted', 'assigned_locker_size': chosen.size, 'real_start': rs, 'real_end': re,
                            'revenue_base': base, 'revenue_size_upcharge': upc, 'revenue_late_fee': late, 'ergonomic_cost': ergo_cost})
            rows.append(row)
            
        self.results = pd.DataFrame(rows)
        
    def summarize(self, tag: str):
        eval_df = self.results[self.results['keep_for_eval']]
        if eval_df.empty: return "--- NO DATA FOR EVALUATION ---"
        
        # === 基本指标计算 ===
        daily_sl = eval_df.groupby('date')['status'].apply(lambda s: (s == 'accepted').mean()).reset_index(name='service_level')
        overall_sl = (eval_df['status']=='accepted').mean()
        min_daily_sl = daily_sl['service_level'].min() if not daily_sl.empty else 0
        breach_days = (daily_sl['service_level'] < SLA_DAILY_TARGET).sum() if not daily_sl.empty else 0
        total_rev = eval_df[['revenue_base', 'revenue_size_upcharge', 'revenue_late_fee']].sum().sum()
        total_ergo_cost = eval_df['ergonomic_cost'].sum()
        
        # ==========================================================
        # === 新增: Utilization (利用率) 计算逻辑 ===
        # ==========================================================
        sim_start_time = eval_df['real_start'].min()
        sim_end_time = eval_df['real_end'].max()
        
        util_s, util_m, util_l, util_overall = 0, 0, 0, 0
        if pd.notna(sim_start_time) and pd.notna(sim_end_time) and sim_end_time > sim_start_time:
            total_period_hours = (sim_end_time - sim_start_time).total_seconds() / 3600.0
            
            occupied_hours = defaultdict(float)
            total_available_hours = defaultdict(float)

            for locker in self.lb.lockers:
                total_available_hours[locker.size] += total_period_hours
                for start, end in locker.schedule:
                    overlap_start = max(start, sim_start_time)
                    overlap_end = min(end, sim_end_time)
                    if overlap_end > overlap_start:
                        occupied_duration_hours = (overlap_end - overlap_start).total_seconds() / 3600.0
                        occupied_hours[locker.size] += occupied_duration_hours
            
            total_occupied = sum(occupied_hours.values())
            total_available = sum(total_available_hours.values())
            
            util_s = (occupied_hours['small'] / total_available_hours['small']) if total_available_hours['small'] > 0 else 0
            util_m = (occupied_hours['medium'] / total_available_hours['medium']) if total_available_hours['medium'] > 0 else 0
            util_l = (occupied_hours['large'] / total_available_hours['large']) if total_available_hours['large'] > 0 else 0
            util_overall = (total_occupied / total_available) if total_available > 0 else 0
        # ==========================================================
        
        summary_text = (
            f"\n--- {tag.upper()} SUMMARY ---\n"
            f"  Overall Service Level: {overall_sl:.3%}\n"
            f"  Minimum Daily SL: {min_daily_sl:.3%}\n"
            f"  Days Breaching SLA Target: {breach_days}\n"
            f"  Total Revenue: ${total_rev:,.2f}\n"
            f"  Total Ergonomic Cost: {total_ergo_cost:,.2f}\n"
            # === 新增: 在输出中加入 Utilization ===
            f"  Utilization (S/M/L/Overall): {util_s:.2%}, {util_m:.2%}, {util_l:.2%}, {util_overall:.2%}"
        )
        
        eval_df.to_csv(os.path.join(OUT_DIR, f"{tag}_results.csv"), index=False)
        with open(os.path.join(OUT_DIR, f"{tag}_summary.txt"), 'w', encoding='utf-8') as f:
            f.write(summary_text)
        return summary_text 

# =========================
# === 并行计算执行部分 ===
# =========================
def run_single_simulation(tag, heuristic_name, demand_df, num_s, num_m, num_l, position):
    """
    封装单个模拟任务，以便于并行调用。
    每个进程都会运行这个函数的一个实例。
    """
    bank = LockerBank(num_s, num_m, num_l)
    agent = AssignmentAgent(bank)
    sim = LockerBankSimulator(bank, demand_df, agent, heuristic=heuristic_name, position=position)
    sim.run()
    summary = sim.summarize(tag=tag)
    return tag, summary

def main():
    if not os.path.exists(INPUT_DEMAND_CSV):
        print(f"Input file not found, creating dummy: {INPUT_DEMAND_CSV}")
        pd.DataFrame({
            'package_id': range(30000), 'min_size_ft3': np.random.randint(1, 19, 30000),
            'real_deposit_dt': pd.to_datetime('2025-10-15') + pd.to_timedelta(np.random.rand(30000) * 30, 'D'),
            'real_pickup_dt': pd.to_datetime('2025-10-15') + pd.to_timedelta(np.random.rand(30000) * 30 + np.random.uniform(0.2, 2.0, 30000), 'D')
        }).to_csv(INPUT_DEMAND_CSV, index=False)
        
    demand_df = pd.read_csv(INPUT_DEMAND_CSV, parse_dates=['real_deposit_dt','real_pickup_dt'])
    print(f"Loaded {len(demand_df):,} records. Output dir: '{OUT_DIR}'")

    simulations_to_run = [
        ('A_T5_Strawman', 't5_strawman'),
        ('B_T5_Smarter', 't5_smarter'),
    ]

    n_cores = os.cpu_count() or 1
    print(f"\n🚀 Starting parallel simulations on {n_cores} cores...")
    print("\n" * (len(simulations_to_run)))
    
    results = Parallel(n_jobs=n_cores)(
        delayed(run_single_simulation)(
            tag,
            heuristic_name,
            demand_df,
            NUM_SMALL,
            NUM_MEDIUM,
            NUM_LARGE,
            i 
        ) for i, (tag, heuristic_name) in enumerate(simulations_to_run)
    )

    print("\n--- All simulations finished. Generating summaries... ---")
    
    for tag, summary_text in sorted(results):
        print(summary_text)

    print(f"\n✅ All simulations complete. Results are in '{OUT_DIR}'.")

if __name__ == '__main__':
    main()
