# -*- coding: utf-8 -*-
"""
Task 5 - Locker Bank Operation Simulator (Directly Integrated with Task 4 Heuristics)
Author: (your name)
Last Update: 2025-10-15

åŠŸèƒ½ï¼š
- è¿è¡Œ Task 5 åŸæœ‰çš„ strawman å’Œ smarter å¯å‘å¼ã€‚
- *** æ–°å¢: ç›´æ¥åµŒå…¥äº† Task 4 çš„ strawman å’Œ cost-minimization (smarter) å¯å‘å¼ä½œä¸ºå¯¹æ¯”ã€‚***
- *** ä¼˜åŒ–: é‡‡ç”¨äº†æ€§èƒ½æ›´ä¼˜çš„ Locker ç±»ï¼ˆbisect æŸ¥æ‰¾ï¼‰ã€‚***
- *** æ€§èƒ½å‡çº§: é‡‡ç”¨å¤šæ ¸å¹¶è¡Œè®¡ç®—ï¼Œå¹¶ä¸ºæ¯ä¸ªå¹¶è¡Œä»»åŠ¡æä¾›ç‹¬ç«‹çš„è¿›åº¦æ¡ã€‚***
- *** æŒ‡æ ‡å¢å¼º: åœ¨æ€»ç»“æŠ¥å‘Šä¸­å¢åŠ äº†å‚¨ç‰©æŸœåˆ©ç”¨ç‡ï¼ˆUtilizationï¼‰æŒ‡æ ‡ã€‚***
"""

import os, json, math, warnings, bisect, time
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from tqdm import tqdm
from collections import defaultdict
from joblib import Parallel, delayed

warnings.filterwarnings("ignore", category=pd.errors.SettingWithCopyWarning)

# =========================
# å…¨å±€å‚æ•°ï¼ˆä¿æŒ Task 5 åŸæœ‰ç»“æ„ï¼‰
# =========================
INPUT_DEMAND_CSV = "Task_3_Outcome/task3_demand_instance_highest_mode.csv"
OUT_DIR = "Task_5_Outcome"
os.makedirs(OUT_DIR, exist_ok=True)

# ... (æ‰€æœ‰å…¶ä»–å‚æ•°ä¿æŒä¸å˜) ...
GRID_HEIGHT = 15
ROW_HEIGHT_CM = 10
BASE_FLOOR_TO_ROW0_CM = 30
SIZE_UNITS = {'small': 1, 'medium': 2, 'large': 3}
USER_HEIGHT_DIST_CM = {'p05': 155, 'p50': 170, 'p95': 185}
ARM_REACH_OFFSET_CM = 70
REACH_SAFETY_MARGIN_CM = 10
POLICY_EARLY_ARRIVE_MAX_MIN = 90
POLICY_LATE_PICKUP_MAX_H = 180
BASE_FEE = 5.0
SIZE_UPCHARGE = {'small': 0.0, 'medium': 1.5, 'large': 3.0}
LATE_FEE_STEP = 0.20
LOOKAHEAD_HOURS = 48
SIZE_PROTECTION_LARGE_THRESHOLD = 0.15
RANDOM_SEED = 20251010
np.random.seed(RANDOM_SEED)
NUM_SMALL = 44
NUM_MEDIUM = 51
NUM_LARGE = 30
SLA_DAILY_TARGET = 0.995
WARMUP_DAYS = 2.0
OVERSIZE_OPPORTUNITY_COST_PER_LEVEL = 4.0

# =========================
# å·¥å…·å‡½æ•°ä¸æ•°æ®ç»“æ„ (è¿™éƒ¨åˆ†å®Œå…¨ä¸å˜)
# =========================
def get_ergonomic_cost(req_size_cat, assigned_size_cat, y_pos):
    y = y_pos + 1; cost = 0.0; size_map = {'small': 1, 'medium': 2, 'large': 3}
    d_req, d_assigned = size_map.get(req_size_cat), size_map.get(assigned_size_cat)
    if d_req is None or d_assigned is None or d_assigned < d_req: return float('inf')
    if d_req == 1 and d_assigned == 1:   cost = 0.01 * (115 - 15*y) if y <= 7 else 0.01 * (-95 + 15*y)
    elif d_req == 1 and d_assigned == 2: cost = 0.01 * ((75 + (65/6)) - (65/6)*y) if y <= 7 else 0.01 * (10 - 7*(65/6) + (65/6)*y)
    elif d_req == 1 and d_assigned == 3: cost = 0.01 * ((50 + (40/6)) - (40/6)*y) if y <= 7 else 0.01 * (10 - 7*(40/6) + (40/6)*y)
    elif d_req == 2 and d_assigned == 2: cost = 0.01 * ((10 - (65/14)) + (65/14)*y)
    elif d_req == 2 and d_assigned == 3: cost = 0.01 * ((10 - (90/14)) + (90/14)*y)
    elif d_req == 3 and d_assigned == 3: cost = 0.01 * ((10 - (90/14)) + (90/14)*y)
    return max(0, cost)

def reachable_row_range_for_user():
    h = np.random.normal(USER_HEIGHT_DIST_CM['p50'], 3.0)
    reach_max_cm = h + ARM_REACH_OFFSET_CM - REACH_SAFETY_MARGIN_CM
    reach_min_cm = max(0, h * 0.35)
    max_row = min(GRID_HEIGHT - 1, int(round((reach_max_cm - BASE_FLOOR_TO_ROW0_CM) / ROW_HEIGHT_CM)))
    min_row = max(0, int(round((reach_min_cm - BASE_FLOOR_TO_ROW0_CM) / ROW_HEIGHT_CM)))
    return (min_row, max_row) if min_row <= max_row else (0, GRID_HEIGHT - 1)

class Locker:
    def __init__(self, locker_id, size_category, position_rc):
        self.id, self.size, self.position, self.schedule = locker_id, size_category, position_rc, []
    def is_available(self, start, end):
        if not self.schedule: return True
        idx = bisect.bisect_right(self.schedule, (start, start))
        if idx > 0 and self.schedule[idx - 1][1] > start: return False
        if idx < len(self.schedule) and self.schedule[idx][0] < end: return False
        return True
    def book(self, start, end): bisect.insort(self.schedule, (start, end))

class LockerBank:
    def __init__(self, num_s, num_m, num_l, height=GRID_HEIGHT):
        self.height = height; self.lockers = []
        self._create_layout(num_s, num_m, num_l)
    def _create_layout(self, num_s, num_m, num_l):
        specs = [('small', num_s), ('medium', num_m), ('large', num_l)]
        current_row, current_col, lid = 0, 0, 0
        for size, cnt in specs:
            h_units = SIZE_UNITS[size]
            for _ in range(cnt):
                if current_row + h_units > self.height: current_row, current_col = 0, current_col + 1
                center_row = current_row + (h_units - 1) / 2.0
                self.lockers.append(Locker(lid, size, (int(round(center_row)), current_col)))
                current_row += h_units; lid += 1
    def total_lockers(self): return len(self.lockers)

class AssignmentAgent:
    def __init__(self, locker_bank: LockerBank):
        self.lb = locker_bank; self._build_req_size_map()
        self.total_large = sum(1 for L in self.lb.lockers if L.size == 'large')
        self.booked_large_count = 0 # <-- æ–°å¢è®¡æ•°å™¨
    def _build_req_size_map(self):
        m = {}; [m.update({s: 'small'}) for s in range(1, 4)]; [m.update({s: 'medium'}) for s in range(4, 10)]; [m.update({s: 'large'}) for s in range(10, 19)]
        self.req_size_map = m
    @staticmethod
    def _size_value(cat): return {'small': 1, 'medium': 2, 'large': 3}.get(cat, 0)
    def _get_candidates(self, req_cat, start, end, rr):
        req_v = self._size_value(req_cat)
        return [L for L in self.lb.lockers if self._size_value(L.size) >= req_v and (rr[0] <= L.position[0] <= rr[1]) and L.is_available(start, end)]
    def _apply_policy_and_price(self, desired_start, desired_end, assigned_size, req_size, locker_position_row=0):
        rs = max(desired_start - pd.Timedelta(minutes=POLICY_EARLY_ARRIVE_MAX_MIN), desired_start.floor('h'))
        re = min(desired_end + pd.Timedelta(hours=POLICY_LATE_PICKUP_MAX_H), desired_end.ceil('h'))
        base, upc = BASE_FEE, SIZE_UPCHARGE.get(assigned_size, 0.0)
        planned, actual = (desired_end - desired_start).total_seconds(), (re - rs).total_seconds()
        late_fee = 0.0
        if planned > 0 and actual > planned: late_fee = int(math.ceil((actual - planned)/planned / LATE_FEE_STEP)) * LATE_FEE_STEP * base
        return rs, re, base, upc, late_fee, get_ergonomic_cost(req_size, assigned_size, locker_position_row)
    def assign_t5_strawman(self, req_cat, start, end, rr):
        cands = self._get_candidates(req_cat, start, end, rr)
        cands.sort(key=lambda L: (self._size_value(L.size) - self._size_value(req_cat), L.position[1], abs(L.position[0] - GRID_HEIGHT//2)))
        return cands[0] if cands else None
    def assign_t5_smarter(self, req_cat, start, end, rr):
        cands = self._get_candidates(req_cat, start, end, rr)
        if not cands: return None
        
        # åœ¨å¾ªç¯å¤–è®¡ç®—ä¸€æ¬¡å¤§å‚¨ç‰©æŸœçš„å ç”¨æƒ…å†µ
        num_large_used = sum(1 for L in self.lb.lockers if L.size == 'large' and L.schedule and L.schedule[-1][1] > start)
        large_remain_ratio = (self.total_large - num_large_used) / self.total_large
        
        # å°†è®¡ç®—å¥½çš„å€¼ä¼ å…¥ _smarter_score
        return max(cands, key=lambda L: self._smarter_score(L, req_cat, start, end, large_remain_ratio))
    def _smarter_score(self, locker: Locker, req_cat, start, end, large_remain_ratio):
        req_v, size_diff = self._size_value(req_cat), self._size_value(locker.size) - self._size_value(req_cat)
        size_score = 1.0 / (1 + 2.0 * max(0, size_diff))
        ergo_soft = 1.0 - min(1.0, abs(locker.position[0] - GRID_HEIGHT/2) / (GRID_HEIGHT/2)) * 0.6
        
        next_start = float('inf')
        # ä½¿ç”¨ bisect å¯ä»¥æ¯”çº¿æ€§æ‰«ææ›´å¿«åœ°æ‰¾åˆ°ä¸‹ä¸€ä¸ªæ—¥ç¨‹
        idx = bisect.bisect_right(locker.schedule, (end, end))
        if idx < len(locker.schedule):
            next_start = locker.schedule[idx][0]
        
        future = 1.0 if next_start == float('inf') else max(0.0, min(1.0, (next_start - end).total_seconds()/3600 / LOOKAHEAD_HOURS))
        
        protect_penalty = 0.0
        if locker.size == 'large' and size_diff > 0:
            # ç›´æ¥ä½¿ç”¨ä¼ å…¥çš„å‚æ•°ï¼Œä¸å†é‡æ–°è®¡ç®—
            if large_remain_ratio < SIZE_PROTECTION_LARGE_THRESHOLD:
                protect_penalty = (SIZE_PROTECTION_LARGE_THRESHOLD - large_remain_ratio) * 0.8
                
        return (0.40 * size_score) + (0.30 * ergo_soft) + (0.30 * future) - protect_penalty
    def assign_t4_strawman(self, req_cat, start, end, rr):
        candidates = self._get_candidates(req_cat, start, end, rr)
        if not candidates: return None
        candidates.sort(key=lambda l: (self._size_value(l.size), l.id))
        return candidates[0]
    def assign_t4_smarter_cost_min(self, req_cat, start, end, rr):
        candidates = self._get_candidates(req_cat, start, end, rr)
        if not candidates: return None
        best_locker, min_cost = None, float('inf')
        req_v = self._size_value(req_cat)
        for locker in candidates:
            ergo_cost = get_ergonomic_cost(req_cat, locker.size, locker.position[0])
            oversize_penalty = (self._size_value(locker.size) - req_v) * OVERSIZE_OPPORTUNITY_COST_PER_LEVEL
            total_cost = ergo_cost + oversize_penalty
            if total_cost < min_cost:
                best_locker, min_cost = locker, total_cost
        return best_locker

class LockerBankSimulator:
    def __init__(self, locker_bank: LockerBank, demand_df: pd.DataFrame, agent: AssignmentAgent, heuristic='smarter', warmup_days=WARMUP_DAYS, position=0):
        self.lb = locker_bank; self.demand = demand_df.copy(); self.agent = agent
        self.heuristic = heuristic; self.warmup_days = warmup_days
        self.results = pd.DataFrame()
        self.position = position 

    def _req_category(self, v_ft3):
        v = int(math.ceil(float(v_ft3))) if pd.notna(v_ft3) else 1
        return self.agent.req_size_map.get(max(1, min(18, v)), 'large')
    
    def run(self):
        start_ts = self.demand['real_deposit_dt'].min(); warmup_cut = start_ts + pd.Timedelta(days=self.warmup_days)
        demand_array = self.demand[['package_id', 'min_size_ft3', 'real_deposit_dt', 'real_pickup_dt']].to_numpy()
        rows = []
        
        progress_bar = tqdm(
            demand_array,
            desc=f"Sim ({self.heuristic})".ljust(30), 
            position=self.position, 
            ncols=100
        )
        
        for r_data in progress_bar:
            pkg, min_size_ft3, start_dt, end_dt = r_data
            start, end = pd.to_datetime(start_dt), pd.to_datetime(end_dt)
            req_cat = self._req_category(min_size_ft3)
            rr = reachable_row_range_for_user()
            
            chosen = None
            if self.heuristic == 't5_strawman': chosen = self.agent.assign_t5_strawman(req_cat, start, end, rr)
            elif self.heuristic == 't5_smarter': chosen = self.agent.assign_t5_smarter(req_cat, start, end, rr)
            elif self.heuristic == 't4_strawman': chosen = self.agent.assign_t4_strawman(req_cat, start, end, rr)
            elif self.heuristic == 't4_smarter_cost_min': chosen = self.agent.assign_t4_smarter_cost_min(req_cat, start, end, rr)

            row = {'package_id': pkg, 'required_size': req_cat, 'status': 'rejected', 'assigned_locker_size': None,
                   'real_start': pd.NaT, 'real_end': pd.NaT, 'revenue_base': 0.0,
                   'revenue_size_upcharge': 0.0, 'revenue_late_fee': 0.0, 'date': start.date(),
                   'keep_for_eval': start >= warmup_cut, 'ergonomic_cost': 0.0}
            if chosen:
                rs, re, base, upc, late, ergo_cost = self.agent._apply_policy_and_price(start, end, chosen.size, req_cat, chosen.position[0])
                chosen.book(rs, re)
                row.update({'status': 'accepted', 'assigned_locker_size': chosen.size, 'real_start': rs, 'real_end': re,
                            'revenue_base': base, 'revenue_size_upcharge': upc, 'revenue_late_fee': late, 'ergonomic_cost': ergo_cost})
            rows.append(row)
            
        self.results = pd.DataFrame(rows)
        
    def summarize(self, tag: str):
        eval_df = self.results[self.results['keep_for_eval']]
        if eval_df.empty: return "--- NO DATA FOR EVALUATION ---"
        
        # === åŸºæœ¬æŒ‡æ ‡è®¡ç®— ===
        daily_sl = eval_df.groupby('date')['status'].apply(lambda s: (s == 'accepted').mean()).reset_index(name='service_level')
        overall_sl = (eval_df['status']=='accepted').mean()
        min_daily_sl = daily_sl['service_level'].min() if not daily_sl.empty else 0
        breach_days = (daily_sl['service_level'] < SLA_DAILY_TARGET).sum() if not daily_sl.empty else 0
        total_rev = eval_df[['revenue_base', 'revenue_size_upcharge', 'revenue_late_fee']].sum().sum()
        total_ergo_cost = eval_df['ergonomic_cost'].sum()
        
        # ==========================================================
        # === æ–°å¢: Utilization (åˆ©ç”¨ç‡) è®¡ç®—é€»è¾‘ ===
        # ==========================================================
        sim_start_time = eval_df['real_start'].min()
        sim_end_time = eval_df['real_end'].max()
        
        util_s, util_m, util_l, util_overall = 0, 0, 0, 0
        if pd.notna(sim_start_time) and pd.notna(sim_end_time) and sim_end_time > sim_start_time:
            total_period_hours = (sim_end_time - sim_start_time).total_seconds() / 3600.0
            
            occupied_hours = defaultdict(float)
            total_available_hours = defaultdict(float)

            for locker in self.lb.lockers:
                total_available_hours[locker.size] += total_period_hours
                for start, end in locker.schedule:
                    overlap_start = max(start, sim_start_time)
                    overlap_end = min(end, sim_end_time)
                    if overlap_end > overlap_start:
                        occupied_duration_hours = (overlap_end - overlap_start).total_seconds() / 3600.0
                        occupied_hours[locker.size] += occupied_duration_hours
            
            total_occupied = sum(occupied_hours.values())
            total_available = sum(total_available_hours.values())
            
            util_s = (occupied_hours['small'] / total_available_hours['small']) if total_available_hours['small'] > 0 else 0
            util_m = (occupied_hours['medium'] / total_available_hours['medium']) if total_available_hours['medium'] > 0 else 0
            util_l = (occupied_hours['large'] / total_available_hours['large']) if total_available_hours['large'] > 0 else 0
            util_overall = (total_occupied / total_available) if total_available > 0 else 0
        # ==========================================================
        
        summary_text = (
            f"\n--- {tag.upper()} SUMMARY ---\n"
            f"  Overall Service Level: {overall_sl:.3%}\n"
            f"  Minimum Daily SL: {min_daily_sl:.3%}\n"
            f"  Days Breaching SLA Target: {breach_days}\n"
            f"  Total Revenue: ${total_rev:,.2f}\n"
            f"  Total Ergonomic Cost: {total_ergo_cost:,.2f}\n"
            # === æ–°å¢: åœ¨è¾“å‡ºä¸­åŠ å…¥ Utilization ===
            f"  Utilization (S/M/L/Overall): {util_s:.2%}, {util_m:.2%}, {util_l:.2%}, {util_overall:.2%}"
        )
        
        eval_df.to_csv(os.path.join(OUT_DIR, f"{tag}_results.csv"), index=False)
        with open(os.path.join(OUT_DIR, f"{tag}_summary.txt"), 'w', encoding='utf-8') as f:
            f.write(summary_text)
        return summary_text 

# =========================
# === å¹¶è¡Œè®¡ç®—æ‰§è¡Œéƒ¨åˆ† ===
# =========================
def run_single_simulation(tag, heuristic_name, demand_df, num_s, num_m, num_l, position):
    """
    å°è£…å•ä¸ªæ¨¡æ‹Ÿä»»åŠ¡ï¼Œä»¥ä¾¿äºå¹¶è¡Œè°ƒç”¨ã€‚
    æ¯ä¸ªè¿›ç¨‹éƒ½ä¼šè¿è¡Œè¿™ä¸ªå‡½æ•°çš„ä¸€ä¸ªå®ä¾‹ã€‚
    """
    bank = LockerBank(num_s, num_m, num_l)
    agent = AssignmentAgent(bank)
    sim = LockerBankSimulator(bank, demand_df, agent, heuristic=heuristic_name, position=position)
    sim.run()
    summary = sim.summarize(tag=tag)
    return tag, summary

def main():
    if not os.path.exists(INPUT_DEMAND_CSV):
        print(f"Input file not found, creating dummy: {INPUT_DEMAND_CSV}")
        pd.DataFrame({
            'package_id': range(30000), 'min_size_ft3': np.random.randint(1, 19, 30000),
            'real_deposit_dt': pd.to_datetime('2025-10-15') + pd.to_timedelta(np.random.rand(30000) * 30, 'D'),
            'real_pickup_dt': pd.to_datetime('2025-10-15') + pd.to_timedelta(np.random.rand(30000) * 30 + np.random.uniform(0.2, 2.0, 30000), 'D')
        }).to_csv(INPUT_DEMAND_CSV, index=False)
        
    demand_df = pd.read_csv(INPUT_DEMAND_CSV, parse_dates=['real_deposit_dt','real_pickup_dt'])
    print(f"Loaded {len(demand_df):,} records. Output dir: '{OUT_DIR}'")

    simulations_to_run = [
        ('A_T5_Strawman', 't5_strawman'),
        ('B_T5_Smarter', 't5_smarter'),
    ]

    n_cores = os.cpu_count() or 1
    print(f"\nğŸš€ Starting parallel simulations on {n_cores} cores...")
    print("\n" * (len(simulations_to_run)))
    
    results = Parallel(n_jobs=n_cores)(
        delayed(run_single_simulation)(
            tag,
            heuristic_name,
            demand_df,
            NUM_SMALL,
            NUM_MEDIUM,
            NUM_LARGE,
            i 
        ) for i, (tag, heuristic_name) in enumerate(simulations_to_run)
    )

    print("\n--- All simulations finished. Generating summaries... ---")
    
    for tag, summary_text in sorted(results):
        print(summary_text)

    print(f"\nâœ… All simulations complete. Results are in '{OUT_DIR}'.")

if __name__ == '__main__':
    main()
