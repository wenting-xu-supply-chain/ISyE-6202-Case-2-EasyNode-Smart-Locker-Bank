import pandas as pd
import datetime
from tqdm import tqdm
import numpy as np

# Note: The code for tasks 1, 3, and 4 is assumed to be present.
# For clarity, only the new Task 5 class and the final execution block are shown below.
# I will create placeholder functions for prior tasks to make this block runnable.

# =============================================================================
# --- Placeholder Functions for Tasks 1, 3, 4 ---
# =============================================================================

def create_locker_bank_df():
    """Placeholder for Task 1's output."""
    locker_data = {
        'locker_id': range(1, 151), # Assuming a bank of 150 lockers
        'size': [3.0]*50 + [9.0]*60 + [18.0]*40,
        'height_level': list(range(1, 6)) * 30
    }
    return pd.DataFrame(locker_data)

def generate_demand_instance(num_days=90):
    """Placeholder for Task 3's output."""
    num_packages = int(140 * num_days) # Avg 140 packages/day
    package_list = []
    start_time = datetime.datetime(2026, 1, 1)
    for i in range(num_packages):
        deposit_offset = np.random.uniform(0, num_days * 24)
        duration = np.random.uniform(5, 48)
        real_deposit_dt = start_time + datetime.timedelta(hours=deposit_offset)
        package_list.append({
            'package_id': i + 1,
            'min_size_ft3': np.random.choice([2, 5, 12]),
            'real_deposit_dt': real_deposit_dt,
            'real_pickup_dt': real_deposit_dt + datetime.timedelta(hours=duration)
        })
    return pd.DataFrame(package_list).sort_values(by='real_deposit_dt').reset_index(drop=True)

# Re-using the class from Task 4
class LockerAssignmentAgent:
    def __init__(self, locker_bank_df):
        self.locker_bank = locker_bank_df.sort_values(by='size').reset_index(drop=True)
        self.locker_reservations = {lid: [] for lid in self.locker_bank['locker_id']}
    def _is_available(self, locker_id, start_dt, end_dt):
        for res_start, res_end in self.locker_reservations.get(locker_id, []):
            if max(start_dt, res_start) < min(end_dt, res_end): return False
        return True
    def _assign_locker(self, locker_id, start_dt, end_dt):
        self.locker_reservations.setdefault(locker_id, []).append((start_dt, end_dt))
    def smarter_heuristic(self, demand_request):
        req_start = demand_request['real_deposit_dt']
        req_end = demand_request['real_pickup_dt']
        req_size = demand_request['min_size_ft3']
        candidates = []
        for _, locker in self.locker_bank.iterrows():
            if locker['size'] >= req_size and self._is_available(locker['locker_id'], req_start, req_end):
                candidates.append(locker)
        if not candidates: return {"status": "Rejected"}
        best_candidate = min(candidates, key=lambda l: l['size'] - req_size)
        self._assign_locker(best_candidate['locker_id'], req_start, req_end)
        return {"status": "Accepted", "locker_id": best_candidate['locker_id']}


# =============================================================================
# --- TASK 5: Locker Bank Operation Simulator ---
# =============================================================================

class LockerBankSimulator:
    """
    Simulates the operation of a locker bank, processes demand,
    and calculates key performance indicators (KPIs).
    """
    def __init__(self, locker_bank_df, demand_df, assignment_agent):
        """
        Initializes the simulator.
        :param locker_bank_df: DataFrame with the locker bank's design.
        :param demand_df: DataFrame with all package demand requests.
        :param assignment_agent: An instance of LockerAssignmentAgent.
        """
        self.locker_bank = locker_bank_df
        self.demand = demand_df
        self.agent = assignment_agent
        
        self.results = []
        
        # --- Financial Assumptions ---
        self.REVENUE_PER_PACKAGE = 2.00
        self.CAPEX_PER_LOCKER = {3.0: 500, 9.0: 800, 18.0: 1200}
        self.OPEX_PER_LOCKER_PER_DAY = 0.15
        self.AMORTIZATION_PERIOD_DAYS = 5 * 365.25

    def run(self):
        """
        Runs the full simulation by processing each demand request in chronological order.
        """
        print("--- Starting Locker Bank Operation Simulation ---")
        if self.demand.empty:
            print("Demand DataFrame is empty. Simulation cannot run.")
            return

        for _, request in tqdm(self.demand.iterrows(), total=len(self.demand), desc="Simulating Operations"):
            # Use the agent's "smarter" heuristic for the decision
            decision = self.agent.smarter_heuristic(request)
            
            # Record the outcome
            self.results.append({
                'package_id': request['package_id'],
                'deposit_time': request['real_deposit_dt'],
                'pickup_time': request['real_pickup_dt'],
                'status': decision['status']
            })
        print("--- Simulation Complete ---")

    def calculate_and_display_kpis(self):
        """
        Calculates and displays all performance metrics after the simulation has run.
        """
        if not self.results:
            print("No results to analyze. Please run the simulation first.")
            return

        results_df = pd.DataFrame(self.results)
        accepted_df = results_df[results_df['status'] == 'Accepted']

        # --- General & Service Metrics ---
        total_requests = len(results_df)
        accepted_requests = len(accepted_df)
        service_level = (accepted_requests / total_requests) * 100 if total_requests > 0 else 0
        
        # --- Utilization Metrics ---
        simulation_start_time = self.demand['real_deposit_dt'].min()
        simulation_end_time = self.demand['real_pickup_dt'].max()
        simulation_duration_hours = (simulation_end_time - simulation_start_time).total_seconds() / 3600
        simulation_duration_days = simulation_duration_hours / 24

        total_available_locker_hours = len(self.locker_bank) * simulation_duration_hours
        
        accepted_df['sojourn_hours'] = (accepted_df['pickup_time'] - accepted_df['deposit_time']).dt.total_seconds() / 3600
        total_occupied_locker_hours = accepted_df['sojourn_hours'].sum()
        
        utilization_rate = (total_occupied_locker_hours / total_available_locker_hours) * 100 if total_available_locker_hours > 0 else 0

        # --- Financial Metrics ---
        # Revenue
        total_revenue = accepted_requests * self.REVENUE_PER_PACKAGE

        # Costs
        total_capex = self.locker_bank['size'].map(self.CAPEX_PER_LOCKER).sum()
        amortized_capex = (total_capex / self.AMORTIZATION_PERIOD_DAYS) * simulation_duration_days
        
        total_daily_opex = len(self.locker_bank) * self.OPEX_PER_LOCKER_PER_DAY
        total_opex = total_daily_opex * simulation_duration_days
        
        total_cost = amortized_capex + total_opex
        
        # Profit
        profit = total_revenue - total_cost

        # --- Display Report ---
        print("\n==============================================")
        print(f"PERFORMANCE REPORT (Simulated Period: {simulation_duration_days:.1f} days)")
        print("==============================================")
        
        print("\n--- Service & Demand ---")
        print(f"Total Demand Requests: {total_requests}")
        print(f"Accepted Packages:     {accepted_requests}")
        print(f"Service Level:         {service_level:.2f}%")

        print("\n--- Operational Metrics ---")
        print(f"Total Occupied Locker-Hours: {total_occupied_locker_hours:,.2f}")
        print(f"Total Available Locker-Hours: {total_available_locker_hours:,.2f}")
        print(f"Overall Utilization Rate:    {utilization_rate:.2f}%")

        print("\n--- Financial Summary ---")
        print(f"Total Revenue:           ${total_revenue:,.2f}")
        print(f"Total Costs (OpEx + Amortized CapEx): ${total_cost:,.2f}")
        print(f"  - Operating Costs (OpEx): ${total_opex:,.2f}")
        print(f"  - Amortized Capital (CapEx): ${amortized_capex:,.2f}")
        print(f"Estimated Profit:        ${profit:,.2f}")
        print("==============================================")


# =============================================================================
# --- Main Execution Block ---
# =============================================================================
if __name__ == '__main__':
    # Step 1: Design the locker bank (from Task 1)
    locker_bank_configuration = create_locker_bank_df()

    # Step 2: Generate a demand scenario (from Task 3)
    # We simulate for 90 days for a reasonably quick yet insightful run.
    demand_scenario = generate_demand_instance(num_days=90)
    
    # Step 3: Initialize the decision-making agent (from Task 4)
    assignment_agent = LockerAssignmentAgent(locker_bank_configuration)
    
    # Step 4: Initialize and run the operation simulator (Task 5)
    simulator = LockerBankSimulator(
        locker_bank_df=locker_bank_configuration,
        demand_df=demand_scenario,
        assignment_agent=assignment_agent
    )
    simulator.run()
    
    # Step 5: Display the final performance report
    simulator.calculate_and_display_kpis()
