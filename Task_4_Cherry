# -*- coding: utf-8 -*-
"""
Task 4 - Refactored & Improved: Dynamic Assignment Simulation with Strategy Pattern
Author: Senior Software Engineer (Refactored from Gemini AI, Improved by user feedback)
Last Update: 2025-10-15

功能概述 (Refactored & Improved):
1) 架构模式: 采用策略模式（Strategy Pattern），将启发式算法模块化，易于扩展。
   - `StrawmanHeuristic`: 实现了简单的“最小适配”策略。
   - `SmarterHeuristic`: 实现了基于综合成本（人体工学+机会成本）的优化策略。
   - `ImprovedSmarterHeuristic`: [新增] 采纳了专家建议，加入了“行带覆盖率惩罚”和“非通用格子奖励”，并优化了成本系数，以保护稀缺资源，提升SL。
2) 效率优化: Locker.is_available() 使用二分查找 (bisect)，将时间冲突检查复杂度从O(n)降至O(log n)。
3) 配置管理: 所有参数集中到 CONFIG 字典中，便于维护和实验。
4) 数据结构: 统一的 SIZE_CONFIG，整合了尺寸的所有属性。
5) 绩效输出与可视化保持不变，功能强大。
"""

import os
import json
import math
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from tqdm import tqdm
from collections import defaultdict
import bisect  # <--- 引入 bisect 模块用于高效查找

# =========================
# 1. 集中化配置 (Centralized Configuration)
# =========================
CONFIG = {
    # ——柜体网格参数——
    'grid': {
        'height': 15,                 # 垂直方向行数
        'row_height_cm': 10,          # 每“行”的近似高度（cm）
        'base_floor_to_row0_cm': 30,  # 地面到第 0 行中线的基准高度
    },
    # ——尺寸统一定义 (Unified Size Definitions)——
    'size_config': {
        'small':  {'units': 1, 'value': 1, 'revenue': 6.10},
        'medium': {'units': 2, 'value': 2, 'revenue': 11.95},
        'large':  {'units': 3, 'value': 3, 'revenue': 16.35},
    },
    # ——人体工学参数——
    'ergonomics': {
        'user_height_dist_cm': {'p05': 155, 'p50': 170, 'p95': 185},
        'arm_reach_offset_cm': 70,
        'reach_safety_margin_cm': 10,
    },
    # ——成本与定价参数——
    'costs': {
        # [修改 - 补丁 B] 降低 oversize 惩罚，避免其过度影响决策
        'oversize_opportunity_cost_per_level': 1.5,
        # [新增 - 补丁 A] 引入行覆盖惩罚系数
        'row_coverage_penalty_coeff': 1.5,
        # [新增 - 补丁 C] 引入非通用格子奖励系数
        'genericity_reward_coeff': 0.05,
    },
    # ——模拟与I/O——
    'simulation': {
        'random_seed': 42,
        'input_demand_csv': "Task_3_Outcome/task3_demand_instance_random_mode.csv",
        'output_dir': "Task_4_Outcome_Improved",
    },
    # ——基线柜体配置——
    'baseline_bank': {
        'small': 27,
        'medium': 32,
        'large': 18,
    }
}

# 初始化输出目录和随机种子
os.makedirs(CONFIG['simulation']['output_dir'], exist_ok=True)
np.random.seed(CONFIG['simulation']['random_seed'])


# =========================
# 工具与成本计算函数
# =========================
def get_ergonomic_cost(req_size_cat: str, assigned_size_cat: str, y_pos: int) -> float:
    # ... (此函数逻辑不变) ...
    y = y_pos + 1
    cost = 0.0
    size_map = {'small': 1, 'medium': 2, 'large': 3}
    d_req, d_assigned = size_map.get(req_size_cat), size_map.get(assigned_size_cat)
    if d_req is None or d_assigned is None or d_assigned < d_req: return float('inf')

    if d_req == 1 and d_assigned == 1:   cost = 0.01 * (115 - 15*y) if y <= 7 else 0.01 * (-95 + 15*y)
    elif d_req == 1 and d_assigned == 2: cost = 0.01 * ((75 + (65/6)) - (65/6)*y) if y <= 7 else 0.01 * (10 - 7*(65/6) + (65/6)*y)
    elif d_req == 1 and d_assigned == 3: cost = 0.01 * ((50 + (40/6)) - (40/6)*y) if y <= 7 else 0.01 * (10 - 7*(40/6) + (40/6)*y)
    elif d_req == 2 and d_assigned == 2: cost = 0.01 * ((10 - (65/14)) + (65/14)*y)
    elif d_req == 2 and d_assigned == 3: cost = 0.01 * ((10 - (90/14)) + (90/14)*y)
    elif d_req == 3 and d_assigned == 3: cost = 0.01 * ((10 - (90/14)) + (90/14)*y)

    return max(0, cost)

def sample_user_height_cm() -> float:
    dist = CONFIG['ergonomics']['user_height_dist_cm']
    r = np.random.rand()
    if r < 0.2: return np.random.normal(dist['p05'], 2.5)
    if r < 0.8: return np.random.normal(dist['p50'], 3.0)
    return np.random.normal(dist['p95'], 2.5)

def get_reachable_row_range() -> tuple[int, int]:
    h = sample_user_height_cm()
    reach_max_cm = h + CONFIG['ergonomics']['arm_reach_offset_cm'] - CONFIG['ergonomics']['reach_safety_margin_cm']
    reach_min_cm = max(0, h * 0.35)
    max_row = min(CONFIG['grid']['height'] - 1, int(round((reach_max_cm - CONFIG['grid']['base_floor_to_row0_cm']) / CONFIG['grid']['row_height_cm'])))
    min_row = max(0, int(round((reach_min_cm - CONFIG['grid']['base_floor_to_row0_cm']) / CONFIG['grid']['row_height_cm'])))
    return (min_row, max_row) if min_row <= max_row else (0, CONFIG['grid']['height'] - 1)

# [新增 - 补丁 A] 增加行带覆盖率权重的计算函数
def row_coverage_weight(row: int, H: int = CONFIG['grid']['height']) -> float:
    """
    计算行的覆盖权重。中心行权重高，表示更“通用”或“稀缺”，应被惩罚。
    """
    center = (H - 1) / 2.0
    # 使用二次函数使中心行权重变大
    return 1.0 + ((row - center) ** 2) / (center ** 2 + 1e-9)

# =========================
# 2. 数据结构优化
# =========================
class Locker:
    def __init__(self, locker_id, size_category, position_rc):
        self.id = locker_id
        self.size = size_category
        self.position = position_rc
        self.schedule = []

    def is_available(self, start, end):
        if not self.schedule: return True
        idx = bisect.bisect_right(self.schedule, (start, start))
        if idx > 0 and self.schedule[idx - 1][1] > start: return False
        if idx < len(self.schedule) and self.schedule[idx][0] < end: return False
        return True

    def book(self, start, end):
        bisect.insort(self.schedule, (start, end))

class LockerBank:
    def __init__(self, config: dict):
        self.height = config['grid']['height']
        self.lockers = []
        self._create_layout(config['baseline_bank'])

    def _create_layout(self, bank_spec):
        specs_ordered = [('large', bank_spec['large']), ('medium', bank_spec['medium']), ('small', bank_spec['small'])]
        lid, r, c = 0, 0, 0
        for size, count in specs_ordered:
            h_units = CONFIG['size_config'][size]['units']
            for _ in range(count):
                if r + h_units > self.height:
                    r, c = 0, c + 1
                center_row = r + (h_units - 1) / 2.0
                self.lockers.append(Locker(lid, size, (int(round(center_row)), c)))
                r += h_units
                lid += 1
    
    def total_lockers(self):
        return len(self.lockers)
    
    def reset(self):
        for locker in self.lockers:
            locker.schedule = []


# =========================
# 3. 核心分配 Agent 与策略模式
# =========================
class HeuristicStrategy:
    def choose_locker(self, available_lockers, req_cat):
        raise NotImplementedError

class StrawmanHeuristic(HeuristicStrategy):
    """稻草人策略：选择尺寸最匹配 (Best Fit) 的第一个可用储物柜"""
    def choose_locker(self, available_lockers, req_cat):
        if not available_lockers:
            return None
        available_lockers.sort(key=lambda l: (CONFIG['size_config'][l.size]['value'], l.id))
        return available_lockers[0]

class SmarterHeuristic(HeuristicStrategy):
    """原始智能策略：选择综合成本最低的储物柜（未修改，用于对比）"""
    def choose_locker(self, available_lockers, req_cat):
        if not available_lockers:
            return None
        best_locker, min_cost = None, float('inf')
        req_v = CONFIG['size_config'][req_cat]['value']
        for locker in available_lockers:
            ergo_cost = get_ergonomic_cost(req_cat, locker.size, locker.position[0])
            # 注意：这里的 oversize_opportunity_cost_per_level 会使用 CONFIG 中更新后的值 (1.5)
            # 如果想完全对比原始 4.0 的效果，需要硬编码或传入参数
            oversize_penalty = (CONFIG['size_config'][locker.size]['value'] - req_v) * 4.0 # 硬编码 4.0 以保留原始行为
            total_cost = ergo_cost + oversize_penalty
            if total_cost < min_cost:
                best_locker, min_cost = locker, total_cost
        return best_locker

class ImprovedSmarterHeuristic(HeuristicStrategy):
    """[新增] 改进后的智能策略：应用了补丁A, B, C"""
    def choose_locker(self, available_lockers, req_cat):
        if not available_lockers:
            return None

        best_locker, min_cost = None, float('inf')
        req_v = CONFIG['size_config'][req_cat]['value']
        C_ROW = CONFIG['costs']['row_coverage_penalty_coeff']
        C_GEN = CONFIG['costs']['genericity_reward_coeff']
        
        for locker in available_lockers:
            row_pos = locker.position[0]
            
            # 1. 人体工学成本
            ergo_cost = get_ergonomic_cost(req_cat, locker.size, row_pos)
            
            # 2. [补丁 B] Oversize 机会成本 (使用 CONFIG 中软化后的值)
            oversize_penalty = (CONFIG['size_config'][locker.size]['value'] - req_v) * CONFIG['costs']['oversize_opportunity_cost_per_level']
            
            # 3. [补丁 A] 行带覆盖率惩罚 (中心行更“贵”)
            coverage_w = row_coverage_weight(row_pos)
            coverage_penalty = C_ROW * coverage_w
            
            # 4. [补丁 C] 非通用格子奖励 (边缘行获得小奖励)
            genericity = 1.0 / coverage_w
            genericity_reward = C_GEN * genericity
            
            # 综合成本：人体工学 + 尺寸机会成本 + 中心行惩罚 - 边缘行奖励
            total_cost = ergo_cost + oversize_penalty + coverage_penalty - genericity_reward
            
            if total_cost < min_cost:
                best_locker, min_cost = locker, total_cost
                
        return best_locker

class AssignmentAgent:
    def __init__(self, locker_bank: LockerBank, strategy: HeuristicStrategy):
        self.lb = locker_bank
        self.strategy = strategy
        self._build_req_size_map()

    def _build_req_size_map(self):
        m = {}
        for s in range(1, 4): m[s] = 'small'
        for s in range(4, 10): m[s] = 'medium'
        for s in range(10, 19): m[s] = 'large'
        self.req_size_map = m

    def _get_req_category(self, min_size_ft3):
        v = int(math.ceil(float(min_size_ft3)))
        return self.req_size_map.get(max(1, min(18, v)), 'large')
    
    def _is_reachable(self, locker: Locker, reachable_range):
        rmin, rmax = reachable_range
        return rmin <= locker.position[0] <= rmax

    def run_simulation(self, demand_df: pd.DataFrame):
        self.lb.reset()
        results, df = [], demand_df.copy().dropna().sort_values('real_deposit_dt').reset_index(drop=True)

        for _, row in tqdm(df.iterrows(), total=len(df), desc=f"Simulating ({self.strategy.__class__.__name__})"):
            req_cat = self._get_req_category(row['min_size_ft3'])
            req_v = CONFIG['size_config'][req_cat]['value']
            start, end = pd.to_datetime(row['real_deposit_dt']), pd.to_datetime(row['real_pickup_dt'])
            reach_range = get_reachable_row_range()

            available_lockers = [
                locker for locker in self.lb.lockers
                if CONFIG['size_config'][locker.size]['value'] >= req_v
                and self._is_reachable(locker, reach_range)
                and locker.is_available(start, end)
            ]
            
            chosen_locker = self.strategy.choose_locker(available_lockers, req_cat)
            
            res = {'package_id': row['package_id'], 'required_size': req_cat,
                   'real_start': start, 'real_end': end, 'status': 'rejected',
                   'assigned_locker_id': None, 'assigned_locker_size': None,
                   'revenue': 0.0, 'ergonomic_cost': 0.0}

            if chosen_locker:
                chosen_locker.book(start, end)
                res.update({
                    'status': 'accepted',
                    'assigned_locker_id': chosen_locker.id,
                    'assigned_locker_size': chosen_locker.size,
                    'revenue': CONFIG['size_config'][chosen_locker.size]['revenue'],
                    'ergonomic_cost': get_ergonomic_cost(req_cat, chosen_locker.size, chosen_locker.position[0])
                })
            results.append(res)

        res_df = pd.DataFrame(results)
        res_df['date'] = res_df['real_start'].dt.date
        return res_df


# =========================
# 绩效度量与可视化 (Unchanged)
# =========================
def compute_and_plot_performance(df_result: pd.DataFrame, total_lockers: int, prefix: str):
    # ... (此部分逻辑完全不变) ...
    output_dir = CONFIG['simulation']['output_dir']
    daily_sl = df_result.groupby('date').agg(
        requests=('package_id', 'count'),
        accepted=('status', lambda s: (s == 'accepted').sum())
    ).reset_index()
    daily_sl['service_level'] = daily_sl['accepted'] / daily_sl['requests']
    
    plt.figure(figsize=(12, 5))
    plt.plot(pd.to_datetime(daily_sl['date']), daily_sl['service_level'], marker='.', linestyle='-', markersize=5)
    plt.axhline(0.995, color='r', linestyle='--', label='Target (99.5%)')
    plt.title(f'{prefix.upper()}: Daily Service Level')
    plt.ylabel('Service Level')
    plt.xlabel('Date')
    plt.ylim(0.95, 1.01)
    plt.grid(True, which='both', linestyle=':')
    plt.legend()
    plt.tight_layout()
    plt.savefig(os.path.join(output_dir, f'{prefix}_daily_service_level.png'), dpi=150)
    plt.close()
    
    overall_sl = daily_sl['accepted'].sum() / daily_sl['requests'].sum() if not daily_sl.empty else 0
    min_daily_sl = daily_sl['service_level'].min() if not daily_sl.empty else 0
    total_revenue = df_result['revenue'].sum()
    total_ergo_cost = df_result['ergonomic_cost'].sum()

    summary = (
        f"--- {prefix.upper()} Summary ---\n"
        f"  Overall Service Level: {overall_sl:.3%}\n"
        f"  Minimum Daily Service Level: {min_daily_sl:.3%}\n"
        f"  Total Revenue: ${total_revenue:,.2f}\n"
        f"  Total Ergonomic Cost: {total_ergo_cost:,.2f}\n"
    )
    print(summary)
    with open(os.path.join(output_dir, f'{prefix}_summary.txt'), 'w') as f:
        f.write(summary)


# =========================
# 主程序
# =========================
def main():
    sim_config = CONFIG['simulation']
    print(f"Starting simulation. Output will be saved to '{sim_config['output_dir']}'")
    
    input_csv = sim_config['input_demand_csv']
    if not os.path.exists(input_csv):
        print(f"\nERROR: Input file not found at '{input_csv}'")
        print("Creating a dummy demand file for demonstration purposes.")
        dummy_data = {
            'package_id': range(10000),
            'min_size_ft3': np.random.randint(1, 19, 10000),
            'real_deposit_dt': pd.to_datetime(np.datetime64('2025-10-15T08:00:00') + np.random.rand(10000) * np.timedelta64(10, 'D')),
        }
        dummy_df = pd.DataFrame(dummy_data)
        dummy_df['real_pickup_dt'] = dummy_df['real_deposit_dt'] + pd.to_timedelta(np.random.uniform(4, 48, 10000), unit='h')
        dummy_df.to_csv(input_csv, index=False)
        print(f"Dummy file '{input_csv}' created.\n")

    demand_df = pd.read_csv(input_csv, parse_dates=['real_deposit_dt', 'real_pickup_dt'])
    
    locker_bank = LockerBank(CONFIG)

    # --- 实例化并运行不同策略 (包括新增的改进策略) ---
    strategies = {
        'strawman': StrawmanHeuristic(),
        'smarter_original': SmarterHeuristic(),
        'smarter_improved': ImprovedSmarterHeuristic(),
    }

    for name, strategy_instance in strategies.items():
        agent = AssignmentAgent(locker_bank, strategy_instance)
        results = agent.run_simulation(demand_df)
        
        output_csv_path = os.path.join(sim_config['output_dir'], f'{name}_assignments.csv')
        results.to_csv(output_csv_path, index=False)
        compute_and_plot_performance(results, locker_bank.total_lockers(), name)

    print(f"\n✅ Simulation complete. All results saved to '{sim_config['output_dir']}'.")

if __name__ == '__main__':
    main()
