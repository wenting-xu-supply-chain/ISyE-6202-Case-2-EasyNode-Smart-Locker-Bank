# -*- coding: utf-8 -*-
"""
Task 5 - Locker Bank Operation Simulator (ERGONOMICS ALIGNED WITH PAPER)
Author: (your name)
Last Update: 2025-10-14
"""

import os, json, math, warnings
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from tqdm import tqdm
from collections import defaultdict

warnings.filterwarnings("ignore", category=pd.errors.SettingWithCopyWarning)

# =========================
# 全局参数
# =========================
INPUT_DEMAND_CSV = "Task_3_Outcome/task3_demand_instance_two_level_cv.csv"
OUT_DIR = "Task_5_Outcome"
os.makedirs(OUT_DIR, exist_ok=True)

GRID_HEIGHT = 15
ROW_HEIGHT_CM = 10
BASE_FLOOR_TO_ROW0_CM = 30
SIZE_UNITS = {'small': 1, 'medium': 2, 'large': 3}

POLICY_EARLY_ARRIVE_MAX_MIN = 90
POLICY_LATE_PICKUP_MAX_H = 180
BASE_FEE = 5.0
SIZE_UPCHARGE = {'small': 0.0, 'medium': 1.5, 'large': 3.0}
LATE_FEE_STEP = 0.20
LOOKAHEAD_HOURS = 48
SIZE_PROTECTION_LARGE_THRESHOLD = 0.15
RANDOM_SEED = 20251010
np.random.seed(RANDOM_SEED)

NUM_SMALL = 27; NUM_MEDIUM = 32; NUM_LARGE = 18
SLA_DAILY_TARGET = 0.995
WARMUP_DAYS = 2.0

# =========================
# 工具函数
# =========================
def row_to_height_cm(row_idx: int) -> float:
    return BASE_FLOOR_TO_ROW0_CM + row_idx * ROW_HEIGHT_CM

def ceil_int(x):
    return int(math.ceil(float(x)))

def ensure_int_ft3(val, lo=1, hi=18):
    if pd.isna(val): return lo
    return max(lo, min(hi, ceil_int(val)))

# =========================
# 数据结构
# =========================
class Locker:
    def __init__(self, locker_id, size_category, position_rc, ergonomic_score):
        self.id = locker_id
        self.size = size_category
        self.position = position_rc
        self.schedule = []
        self.ergonomic_score = ergonomic_score

    def is_available(self, start, end):
        for s, e in self.schedule:
            if start < e and end > s: return False
        return True

    def book(self, start, end):
        self.schedule.append((start, end))
        self.schedule.sort(key=lambda x: x[0])

class LockerBank:
    def __init__(self, num_s, num_m, num_l, height=GRID_HEIGHT):
        self.height = height
        self.lockers = []
        self._create_layout(num_s, num_m, num_l)

    ### NEW: Ergonomic score function based on the paper ###
    def _calculate_ergonomic_score_from_paper(self, center_row: int) -> float:
        h = row_to_height_cm(center_row)
        cost = 0.0
        if h < 70:
            cost = 0.05 * (70 - h)
        elif h >= 140:
            cost = 0.1 * (h - 140)
        score = 1.0 / (1.0 + cost)
        return score

    def _create_layout(self, num_s, num_m, num_l):
        specs = [('small', num_s), ('medium', num_m), ('large', num_l)]
        current_row, current_col, lid = 0, 0, 0
        for size, cnt in specs:
            h_units = SIZE_UNITS[size]
            for _ in range(cnt):
                if current_row + h_units > self.height:
                    current_row, current_col = 0, current_col + 1
                center_row = current_row + (h_units // 2)
                ergo_score = self._calculate_ergonomic_score_from_paper(center_row)
                self.lockers.append(Locker(lid, size, (center_row, current_col), ergo_score))
                current_row += h_units
                lid += 1
    def total_lockers(self): return len(self.lockers)

# =========================
# Task 4 启发式 Agent
# =========================
class AssignmentAgent:
    def __init__(self, locker_bank: LockerBank):
        self.lb = locker_bank
        self.req_size_map = self._build_req_size_map()
        self.base_fee = BASE_FEE
        self.size_upcharge = SIZE_UPCHARGE
        self.total_large = sum(1 for L in self.lb.lockers if L.size == 'large')

    @staticmethod
    def _build_req_size_map():
        m = {}; [m.update({s: 'small'}) for s in range(1, 4)]; [m.update({s: 'medium'}) for s in range(4, 10)]; [m.update({s: 'large'}) for s in range(10, 19)]; return m
    @staticmethod
    def _size_value(cat): return SIZE_UNITS[cat]
    
    ### MODIFIED: Removed user reachability filter ###
    def _get_candidates(self, req_cat):
        req_v = self._size_value(req_cat)
        feas = [L for L in self.lb.lockers if self._size_value(L.size) >= req_v]
        feas.sort(key=lambda L: (self._size_value(L.size) - req_v, L.position[1], abs(L.position[0] - GRID_HEIGHT//2)))
        return feas

    def _large_remaining_ratio(self):
        used_large = sum(1 for L in self.lb.lockers if L.size=='large' and L.schedule)
        return max(0, self.total_large - used_large) / max(1, self.total_large)

    def _smarter_score(self, locker: Locker, req_cat, start, end):
        req_v = self._size_value(req_cat); size_diff = self._size_value(locker.size) - req_v
        size_score = 1.0 / (1 + 2.0 * max(0, size_diff))
        ergo_score = locker.ergonomic_score
        next_start = float('inf')
        for s, e in locker.schedule:
            if s >= end: next_start = s; break
        future = 1.0 if next_start == float('inf') else max(0.0, min(1.0, (next_start - end).total_seconds()/3600 / LOOKAHEAD_HOURS))
        protect_penalty = 0.0
        if locker.size == 'large' and size_diff > 0:
            if self._large_remaining_ratio() < SIZE_PROTECTION_LARGE_THRESHOLD:
                protect_penalty = 0.5
        return (0.40 * size_score) + (0.35 * ergo_score) + (0.25 * future) - protect_penalty

    def _apply_policy_and_price(self, desired_start, desired_end, assigned_size, req_size):
        rs = max(desired_start - pd.Timedelta(minutes=POLICY_EARLY_ARRIVE_MAX_MIN), desired_start.floor('h'))
        re = min(desired_end + pd.Timedelta(hours=POLICY_LATE_PICKUP_MAX_H), desired_end.ceil('h'))
        if re <= rs: re = rs + pd.Timedelta(minutes=1)
        base, upc = self.base_fee, self.size_upcharge.get(assigned_size, 0.0)
        planned, actual = (desired_end - desired_start).total_seconds(), (re - rs).total_seconds()
        late_fee = 0.0
        if planned > 0 and actual > planned: late_fee = int(math.ceil((actual - planned)/planned / LATE_FEE_STEP)) * LATE_FEE_STEP * base
        return rs, re, base, upc, late_fee

    def assign_strawman(self, req_cat, start, end):
        for L in self._get_candidates(req_cat):
            if L.is_available(start, end): return L
        return None

    def assign_smarter(self, req_cat, start, end):
        cands = [L for L in self._get_candidates(req_cat) if L.is_available(start, end)]
        if not cands: return None
        return max(cands, key=lambda L: self._smarter_score(L, req_cat, start, end))

# =========================
# KPI & 可视化
# =========================
# ... [All KPI and Plotting functions remain the same] ...
def compute_daily_service_level(df_result: pd.DataFrame):
    if df_result.empty: return pd.DataFrame(columns=['date', 'requests', 'accepted', 'service_level'])
    g = df_result.groupby('date').agg(requests=('package_id','count'), accepted=('status', lambda s: (s=='accepted').sum())).reset_index()
    g['service_level'] = g['accepted'] / g['requests']
    return g
def compute_hourly_utilization(df_result: pd.DataFrame, total_lockers: int):
    acc = df_result[df_result['status']=='accepted'].copy()
    if acc.empty: return pd.DataFrame({'hour': range(24), 'utilization': [0.0]*24})
    occ = defaultdict(int)
    for _, r in acc.iterrows():
        t = pd.to_datetime(r['real_start']).floor('h'); end = pd.to_datetime(r['real_end'])
        while t < end: occ[t] += 1; t += pd.Timedelta(hours=1)
    df = pd.DataFrame({'ts': list(occ.keys()), 'occupied': list(occ.values())})
    if df.empty: return pd.DataFrame({'hour': range(24), 'utilization': [0.0]*24})
    df['hour'] = pd.to_datetime(df['ts']).dt.hour
    hourly = df.groupby('hour')['occupied'].mean().reset_index()
    hourly['utilization'] = hourly['occupied'] / max(1, total_lockers)
    return pd.DataFrame({'hour': range(24)}).merge(hourly[['hour','utilization']], on='hour', how='left').fillna(0.0)
def compute_revenue_breakdown(df_result: pd.DataFrame):
    acc = df_result[df_result['status']=='accepted']
    tot = acc[['revenue_base','revenue_size_upcharge','revenue_late_fee']].sum()
    return pd.DataFrame({'component': ['base','size_up','late_fee'],
                         'revenue': [float(tot.get('revenue_base',0.0)), float(tot.get('revenue_size_upcharge',0.0)), float(tot.get('revenue_late_fee',0.0))]})
def plot_daily_service_level(daily_df, path):
    if daily_df.empty: return
    plt.figure(figsize=(15,5)); plt.plot(pd.to_datetime(daily_df['date']), daily_df['service_level'])
    plt.axhline(SLA_DAILY_TARGET, linestyle='--', color='r', label=f'{SLA_DAILY_TARGET*100}% Target')
    plt.title('Daily Service Level (Full 5-Year Period)'); plt.xlabel('Date'); plt.ylabel('Service Level')
    plt.legend(); plt.tight_layout(); plt.savefig(path, dpi=150); plt.close()
def plot_hourly_utilization(hourly_df, path):
    if hourly_df.empty: return
    plt.figure(figsize=(8,4)); plt.plot(hourly_df['hour'], hourly_df['utilization'])
    plt.title('Average Utilization by Hour of Day'); plt.xlabel('Hour'); plt.ylabel('Utilization')
    plt.xticks(range(0,24,2)); plt.tight_layout(); plt.savefig(path, dpi=150); plt.close()
def plot_revenue_breakdown(rev_df, path):
    if rev_df.empty: return
    plt.figure(figsize=(6,4)); plt.bar(rev_df['component'], rev_df['revenue'])
    plt.title('Revenue Breakdown'); plt.xlabel('Component'); plt.ylabel('Revenue')
    plt.tight_layout(); plt.savefig(path, dpi=150); plt.close()

# =========================
# Task 5 仿真器
# =========================
class LockerBankSimulator:
    def __init__(self, locker_bank: LockerBank, demand_df: pd.DataFrame, agent: AssignmentAgent,
                 heuristic='smarter', warmup_days=WARMUP_DAYS):
        self.lb = locker_bank; self.demand = demand_df.copy(); self.agent = agent; self.heuristic = heuristic
        self.warmup_days = warmup_days; self.results = pd.DataFrame()

    def _req_category(self, v_ft3):
        v = ensure_int_ft3(v_ft3)
        if 1 <= v <= 3: return 'small'
        elif 4 <= v <= 9: return 'medium'
        else: return 'large'

    def run(self):
        if self.demand.empty: print("No demand!"); return
        start_ts = self.demand['real_deposit_dt'].min(); warmup_cut = start_ts + pd.Timedelta(days=self.warmup_days)
        rows = []
        for _, r in tqdm(self.demand.iterrows(), total=len(self.demand), desc=f"Simulating ({self.heuristic})", ncols=90):
            pkg = r['package_id']; req_cat = self._req_category(r['min_size_ft3'])
            start, end = pd.to_datetime(r['real_deposit_dt']), pd.to_datetime(r['real_pickup_dt'])
            
            ### MODIFIED: Removed user-specific reachability logic ###
            chosen = self.agent.assign_strawman(req_cat, start, end) if self.heuristic == 'strawman' else self.agent.assign_smarter(req_cat, start, end)

            row = {'package_id': pkg, 'required_size': req_cat, 'status': 'rejected',
                   'reason': 'rejected_full', # Simplified reason
                   'desired_start': start, 'desired_end': end,
                   'date': start.date(), 'keep_for_eval': start >= warmup_cut}
            if chosen:
                rs, re, base, upc, late = self.agent._apply_policy_and_price(start, end, chosen.size, req_cat)
                chosen.book(rs, re)
                row.update({'status': 'accepted', 'reason': 'accepted_exact' if chosen.size == req_cat else 'accepted_oversize',
                            'assigned_locker_id': chosen.id, 'assigned_locker_size': chosen.size, 'real_start': rs, 'real_end': re,
                            'revenue_base': base, 'revenue_size_upcharge': upc, 'revenue_late_fee': late})
            rows.append(row)
        self.results = pd.DataFrame(rows)

    def summarize(self, tag: str):
        # ... [Summarize logic remains the same] ...
        if self.results.empty: print("No results to summarize."); return None
        res = self.results.copy(); eval_df = res[res['keep_for_eval']].copy()
        if eval_df.empty: return {'overall_sl': 0, 'min_daily_sla': 0, 'breach_days': len(res['date'].unique()), 'total_revenue': 0, 
                                 'daily': pd.DataFrame(), 'hourly': pd.DataFrame(), 'rev': pd.DataFrame()}
        daily = compute_daily_service_level(eval_df)
        min_daily_sla = daily['service_level'].min() if not daily.empty else 0.0
        breach_days = int((daily['service_level'] < SLA_DAILY_TARGET).sum()) if not daily.empty else 0
        total_lockers = self.lb.total_lockers()
        hourly = compute_hourly_utilization(eval_df, total_lockers)
        rev = compute_revenue_breakdown(eval_df)
        total_revenue = rev['revenue'].sum()
        overall_sl = (eval_df['status']=='accepted').mean()
        print(f"\n[{tag}]  Overall SL: {overall_sl:.2%} | Min Daily SL: {min_daily_sla:.2%} | Breach Days: {breach_days}")
        print(f"[{tag}]  Revenue (base, size_up, late): {tuple(rev['revenue'].round(2))}")
        prefix = 'A_' if tag.lower().startswith('straw') else 'B_'
        eval_df.to_csv(os.path.join(OUT_DIR, f"{prefix}results_eval.csv"), index=False)
        daily.to_csv(os.path.join(OUT_DIR, f"{prefix}daily_service_level.csv"), index=False)
        hourly.to_csv(os.path.join(OUT_DIR, f"{prefix}hourly_utilization.csv"), index=False)
        rev.to_csv(os.path.join(OUT_DIR, f"{prefix}revenue_breakdown.csv"), index=False)
        plot_daily_service_level(daily, os.path.join(OUT_DIR, f"{prefix}daily_service_level.png"))
        plot_hourly_utilization(hourly, os.path.join(OUT_DIR, f"{prefix}hourly_utilization.png"))
        plot_revenue_breakdown(rev, os.path.join(OUT_DIR, f"{prefix}revenue_breakdown.png"))

# =========================
# 主程序
# =========================
def main():
    if not os.path.exists(INPUT_DEMAND_CSV):
        raise FileNotFoundError(f"未找到 Task 3 产出文件：{INPUT_DEMAND_CSV}")
    demand_df = pd.read_csv(INPUT_DEMAND_CSV, parse_dates=['real_deposit_dt','real_pickup_dt']).tail(20000)
    print(f"Loaded full 5-year demand data with {len(demand_df):,} records.")
    
    bank1 = LockerBank(NUM_SMALL, NUM_MEDIUM, NUM_LARGE)
    bank2 = LockerBank(NUM_SMALL, NUM_MEDIUM, NUM_LARGE)
    agent_straw = AssignmentAgent(bank1); agent_smart = AssignmentAgent(bank2)
    
    print("\n--- Running Simulation for 'Strawman' Heuristic (Paper Ergonomics) ---")
    sim_a = LockerBankSimulator(bank1, demand_df, agent_straw, heuristic='strawman')
    sim_a.run()
    sim_a.summarize(tag='Strawman')

    print("\n--- Running Simulation for 'Smarter' Heuristic (Paper Ergonomics) ---")
    sim_b = LockerBankSimulator(bank2, demand_df, agent_smart, heuristic='smarter')
    sim_b.run()
    sim_b.summarize(tag='Smarter')
    
    # ... [Parameter and README saving logic remains the same] ...
    params = {'input_csv': INPUT_DEMAND_CSV, 'num_small': NUM_SMALL, 'num_medium': NUM_MEDIUM, 'num_large': NUM_LARGE}
    with open(os.path.join(OUT_DIR, 'task5_params_paper_ergo.json'), 'w', encoding='utf-8') as f:
        json.dump(params, f, indent=2, ensure_ascii=False)
    with open(os.path.join(OUT_DIR, 'README_Task5.txt'), 'w', encoding='utf-8') as f:
        f.write("Task 5 Simulation (using Paper Ergonomics Model)\n...")
    print(f"\n✅ 所有结果已输出至目录：{OUT_DIR}")

if __name__ == '__main__':
    main()
