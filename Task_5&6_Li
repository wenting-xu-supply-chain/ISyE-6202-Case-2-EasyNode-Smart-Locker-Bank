# -*- coding: utf-8 -*-
"""
Task 5/6 - Locker Bank Operation Simulator (MODIFIED to align with Task 7 Objective)
Author: (your name)
Last Update: 2025-10-16

Changes:
- Integrated the detailed economic parameters and objective function from Task 7.
- The `summarize` function now calculates KPIs (Revenue, Cost, Oversize Rate)
  and a final Objective Score consistent with the Task 7 optimization logic.
- The core parallel simulation engine remains unchanged.
"""

import os, json, math, warnings, bisect, time
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from tqdm import tqdm
from collections import defaultdict
from joblib import Parallel, delayed

warnings.filterwarnings("ignore", category=pd.errors.SettingWithCopyWarning)

# =========================
# Global Parameters
# =========================
INPUT_DEMAND_CSV = "Task_3_Outcome/task3_demand_instance_random_mode.csv"
OUT_DIR = "Task_5_Outcome_with_T7_Objective"
os.makedirs(OUT_DIR, exist_ok=True)

GRID_HEIGHT = 15
SIZE_UNITS = {'small': 1, 'medium': 2, 'large': 3}
LOCKER_CAPACITY_FT3 = {'small': 3.0, 'medium': 9.0, 'large': 18.0}
RANDOM_SEED = 20251010
np.random.seed(RANDOM_SEED)

# Baseline configuration to be evaluated
NUM_SMALL = 44
NUM_MEDIUM = 51
NUM_LARGE = 30

SLA_DAILY_TARGET = 0.995
WARMUP_DAYS = 2.0

# --- NEW: Economic parameters imported from Task 7 script ---
R_D = {'small': 6.10, 'medium': 11.95, 'large': 16.35}
C_L = {'small': 700.0, 'medium': 1100.0, 'large': 1600.0}
C_M = 50.0
C_W = 500.0
C_S = 50.0
AMORT_LAMBDA = 30
N_M_COVER = 14
# -----------------------------------------------------------

# --- NEW: Objective function parameters from Task 7 script ---
LAMBDA_SLA = 3e7
MU_OVERSIZE = 1e6
XI_UNDERUTIL = 4e5
TARGET_VOL_UTIL = 0.72
# -------------------------------------------------------------

# (Ergonomic cost, user sampling, and other policy parameters remain unchanged)
# ... [Full block of existing functions like get_ergonomic_cost, reachable_row_range_for_user, etc.] ...
def get_ergonomic_cost(req_size_cat, assigned_size_cat, y_pos):
    y = y_pos + 1; cost = 0.0; size_map = {'small': 1, 'medium': 2, 'large': 3}
    d_req, d_assigned = size_map.get(req_size_cat), size_map.get(assigned_size_cat)
    if d_req is None or d_assigned is None or d_assigned < d_req: return float('inf')
    if d_req == 1 and d_assigned == 1:   cost = 0.01 * (115 - 15*y) if y <= 7 else 0.01 * (-95 + 15*y)
    elif d_req == 1 and d_assigned == 2: cost = 0.01 * ((75 + (65/6)) - (65/6)*y) if y <= 7 else 0.01 * (10 - 7*(65/6) + (65/6)*y)
    elif d_req == 1 and d_assigned == 3: cost = 0.01 * ((50 + (40/6)) - (40/6)*y) if y <= 7 else 0.01 * (10 - 7*(40/6) + (40/6)*y)
    elif d_req == 2 and d_assigned == 2: cost = 0.01 * ((10 - (65/14)) + (65/14)*y)
    elif d_req == 2 and d_assigned == 3: cost = 0.01 * ((10 - (90/14)) + (90/14)*y)
    elif d_req == 3 and d_assigned == 3: cost = 0.01 * ((10 - (90/14)) + (90/14)*y)
    return max(0, cost)
def reachable_row_range_for_user():
    h = np.random.normal(170, 3.0)
    reach_max_cm = h + 70 - 10
    reach_min_cm = max(0, h * 0.35)
    max_row = min(GRID_HEIGHT - 1, int(round((reach_max_cm - 30) / 10)))
    min_row = max(0, int(round((reach_min_cm - 30) / 10)))
    return (min_row, max_row) if min_row <= max_row else (0, GRID_HEIGHT - 1)


# (Locker, LockerBank, AssignmentAgent, LockerBankSimulator classes remain structurally the same)
# ... [Full, unchanged class definitions for Locker, LockerBank, etc.] ...
class Locker:
    def __init__(self, locker_id, size_category, position_rc):
        self.id, self.size, self.position, self.schedule = locker_id, size_category, position_rc, []
    def is_available(self, start, end):
        if not self.schedule: return True
        idx = bisect.bisect_right(self.schedule, (start, start))
        if idx > 0 and self.schedule[idx - 1][1] > start: return False
        if idx < len(self.schedule) and self.schedule[idx][0] < end: return False
        return True
    def book(self, start, end): bisect.insort(self.schedule, (start, end))

class LockerBank:
    def __init__(self, num_s, num_m, num_l, height=GRID_HEIGHT):
        self.height = height; self.lockers = []
        self._create_layout(num_s, num_m, num_l)
        self.width = (max((L.position[1] for L in self.lockers), default=-1) + 1)
    def _create_layout(self, num_s, num_m, num_l):
        specs = [('small', num_s), ('medium', num_m), ('large', num_l)]
        current_row, current_col, lid = 0, 0, 0
        for size, cnt in specs:
            h_units = SIZE_UNITS[size]
            for _ in range(cnt):
                if current_row + h_units > self.height: current_row, current_col = 0, current_col + 1
                center_row = current_row + (h_units - 1) / 2.0
                self.lockers.append(Locker(lid, size, (int(round(center_row)), current_col)))
                current_row += h_units; lid += 1
    def total_lockers(self): return len(self.lockers)

# --- NEW: Objective function copied directly from Task 7 ---
def _objective(kpi: dict) -> float:
    """Profit core + soft penalties (SLA, oversize, under-utilization)."""
    score = float(kpi['revenue'] - kpi['total_cost'])
    if kpi['overall_sl'] < SLA_DAILY_TARGET:
        score -= LAMBDA_SLA * (SLA_DAILY_TARGET - kpi['overall_sl'])
    score -= MU_OVERSIZE * float(kpi.get('oversize_rate', 0.0))
    util_gap = max(0.0, TARGET_VOL_UTIL - float(kpi.get('vol_util_overall', 0.0)))
    score -= XI_UNDERUTIL * util_gap
    return score
# ---------------------------------------------------------

class LockerBankSimulator:
    # ... (The __init__, _req_category, and run methods are unchanged) ...
    def __init__(self, locker_bank: LockerBank, demand_df: pd.DataFrame, agent, heuristic='smarter', warmup_days=WARMUP_DAYS, position=0):
        self.lb, self.demand, self.agent = locker_bank, demand_df.copy(), agent
        self.heuristic, self.warmup_days = heuristic, warmup_days
        self.results, self.position = pd.DataFrame(), position
    def _req_category(self, v_ft3):
        v = int(math.ceil(float(v_ft3))) if pd.notna(v_ft3) else 1
        if v <= 3: return 'small'
        if v <= 9: return 'medium'
        return 'large'
    def run(self):
        # ... (simulation loop is unchanged) ...
        start_ts = self.demand['real_deposit_dt'].min(); warmup_cut = start_ts + pd.Timedelta(days=self.warmup_days)
        demand_array = self.demand[['package_id', 'min_size_ft3', 'real_deposit_dt', 'real_pickup_dt']].to_numpy()
        rows = []
        progress_bar = tqdm(demand_array, desc=f"Sim ({self.heuristic})".ljust(30), position=self.position, ncols=100)
        for r_data in progress_bar:
            pkg, min_size_ft3, start_dt, end_dt = r_data
            start, end = pd.to_datetime(start_dt), pd.to_datetime(end_dt)
            req_cat = self._req_category(min_size_ft3)
            rr = reachable_row_range_for_user()
            chosen = self.agent.assign_t5_smarter(req_cat, start, end, rr) # Assuming we always use the best heuristic for eval
            row = {'package_id': pkg, 'required_size': req_cat, 'package_volume_ft3': min_size_ft3, 'status': 'rejected', 'assigned_locker_size': None, 'real_start': pd.NaT, 'real_end': pd.NaT, 'date': start.date(), 'keep_for_eval': start >= warmup_cut, 'ergonomic_cost': 0.0}
            if chosen:
                row.update({'status': 'accepted', 'assigned_locker_size': chosen.size, 'ergonomic_cost': get_ergonomic_cost(req_cat, chosen.size, chosen.position[0])})
            rows.append(row)
        self.results = pd.DataFrame(rows)


    # --- MODIFIED: The summarize function is completely replaced ---
    def summarize(self, tag: str):
        eval_df = self.results[self.results['keep_for_eval']]
        if eval_df.empty:
            print(f"[{tag}] --- NO DATA FOR EVALUATION ---")
            return "--- NO DATA FOR EVALUATION ---"

        # --- KPI Calculation aligned with Task 7 ---
        # 1. Service Level
        overall_sl = (eval_df['status'] == 'accepted').mean()

        # 2. Revenue (using R_D from economic parameters)
        served = eval_df[eval_df['status'] == 'accepted']
        S_d = served.groupby('required_size').size().reindex(['small', 'medium', 'large'], fill_value=0)
        revenue = float(sum(R_D[d] * S_d[d] for d in ['small', 'medium', 'large']))

        # 3. Costs
        ergo_cost = float(served['ergonomic_cost'].sum())

        W = self.lb.width
        H = self.lb.height
        M = int(np.ceil(W / N_M_COVER)) if W > 0 else 0
        cfg = {'small': NUM_SMALL, 'medium': NUM_MEDIUM, 'large': NUM_LARGE} # Assuming fixed config for this run
        capex = sum(C_L[d] * cfg[d] for d in ['small', 'medium', 'large']) + C_M * M + C_W * W + 2.0 * C_S * (W + H)
        capex_amort = AMORT_LAMBDA * capex
        total_cost = ergo_cost + capex_amort
        
        # 4. Utilization and Oversize Rate
        if served.empty:
            vol_util_overall, oversize_rate = 0.0, 0.0
        else:
            cap = served['assigned_locker_size'].map(LOCKER_CAPACITY_FT3)
            vol_util_overall = float(served['package_volume_ft3'].sum() / cap.sum()) if cap.sum() > 0 else 0.0
            oversize_rate = float((served['assigned_locker_size'] != served['required_size']).mean())
            
        # 5. Package all KPIs for the objective function
        kpi_dict = {
            'overall_sl': overall_sl,
            'revenue': revenue,
            'total_cost': total_cost,
            'oversize_rate': oversize_rate,
            'vol_util_overall': vol_util_overall
        }
        
        # 6. Calculate the final objective score
        objective_score = _objective(kpi_dict)

        # 7. Generate Summary Report
        summary_text = (
            f"\n--- {tag.upper()} SUMMARY (T7 OBJECTIVE ALIGNED) ---\n"
            f"  Service Level: {overall_sl:.3%}\n"
            f"  Volume Utilization: {vol_util_overall:.2%}\n"
            f"  Oversize Rate: {oversize_rate:.2%}\n"
            f"  ------------------------------------------\n"
            f"  Revenue: ${revenue:,.2f}\n"
            f"  Total Cost (Ergo + Amort. CAPEX): ${total_cost:,.2f}\n"
            f"  PROFIT (Rev - Cost): ${revenue - total_cost:,.2f}\n"
            f"  ------------------------------------------\n"
            f"  FINAL OBJECTIVE SCORE: {objective_score:,.2f}"
        )

        eval_df.to_csv(os.path.join(OUT_DIR, f"{tag}_results.csv"), index=False)
        with open(os.path.join(OUT_DIR, f"{tag}_summary.txt"), 'w', encoding='utf-8') as f:
            f.write(summary_text)

        return summary_text
    # --- END OF MODIFIED SECTION ---

# (The main execution block and AssignmentAgent can remain largely the same,
# but we'll simplify the main block to reflect a focused evaluation run)
class AssignmentAgent: # A simplified agent for this script
    def __init__(self, locker_bank: LockerBank):
        self.lb = locker_bank
    def assign_t5_smarter(self, req_cat, start, end, rr):
        cands = [L for L in self.lb.lockers if {'small':1,'medium':2,'large':3}[L.size] >= {'small':1,'medium':2,'large':3}[req_cat] and (rr[0] <= L.position[0] <= rr[1]) and L.is_available(start, end)]
        if not cands: return None
        return min(cands, key=lambda L: (abs(L.position[0] - GRID_HEIGHT / 2)))

def run_single_simulation(tag, demand_df, num_s, num_m, num_l, position):
    bank = LockerBank(num_s, num_m, num_l)
    agent = AssignmentAgent(bank)
    # Always use the best heuristic for evaluation
    sim = LockerBankSimulator(bank, demand_df, agent, heuristic='smarter', position=position)
    sim.run()
    summary = sim.summarize(tag=tag)
    return tag, summary

def main():
    if not os.path.exists(INPUT_DEMAND_CSV):
        raise FileNotFoundError(f"Input file not found: {INPUT_DEMAND_CSV}")
        
    demand_df = pd.read_csv(INPUT_DEMAND_CSV, parse_dates=['real_deposit_dt','real_pickup_dt'])
    # Optional: Sample for faster runs
    # demand_df = demand_df.sample(20000) 
    print(f"Loaded {len(demand_df):,} records. Output dir: '{OUT_DIR}'")

    simulations_to_run = [
        ('A_Baseline_Design_Eval', NUM_SMALL, NUM_MEDIUM, NUM_LARGE),
        # You could add other designs here to compare, e.g.:
        # ('B_Improved_Design_Eval', 40, 60, 25), 
    ]

    n_cores = os.cpu_count() or 1
    print(f"\n🚀 Starting parallel simulations on {n_cores} cores...")
    print("\n" * (len(simulations_to_run)))
    
    results = Parallel(n_jobs=n_cores)(
        delayed(run_single_simulation)(
            tag, demand_df, num_s, num_m, num_l, i
        ) for i, (tag, num_s, num_m, num_l) in enumerate(simulations_to_run)
    )

    print("\n--- All simulations finished. Final Summaries: ---")
    
    for _, summary_text in sorted(results):
        print(summary_text)

    print(f"\n✅ All simulations complete. Results are in '{OUT_DIR}'.")

if __name__ == '__main__':
    main()
