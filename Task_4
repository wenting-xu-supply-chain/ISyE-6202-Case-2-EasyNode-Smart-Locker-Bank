import pandas as pd
import datetime

class LockerAssignmentAgent:
    """
    An agent that manages the state of the locker bank and processes assignment
    requests using different heuristics.
    """
    def __init__(self, locker_bank_df):
        """
        Initializes the agent.
        :param locker_bank_df: A DataFrame containing all locker information.
                              Required columns: 'locker_id', 'size', 'height_level'
        """
        # For efficiency, sort the lockers by size
        self.locker_bank = locker_bank_df.sort_values(by='size').reset_index(drop=True)
        
        # locker_reservations stores the booking schedule for each locker
        # Format: {locker_id: [(start_time_1, end_time_1), (start_time_2, end_time_2), ...]}
        self.locker_reservations = {lid: [] for lid in self.locker_bank['locker_id']}
        self.reset_stats()

    def reset_stats(self):
        """Resets internal statistics, useful for running multiple simulations."""
        self.accepted_requests = 0
        self.rejected_requests = 0
        self.processed_requests = 0

    def _is_available(self, locker_id, start_dt, end_dt):
        """
        Checks if a locker is fully available during a specified time interval
        (datetime objects).
        """
        for res_start, res_end in self.locker_reservations[locker_id]:
            # Check for any overlap in the time intervals
            if max(start_dt, res_start) < min(end_dt, res_end):
                return False
        return True

    def _assign_locker(self, locker_id, start_dt, end_dt):
        """
        Assigns a new reservation to the specified locker and keeps the
        reservation list sorted.
        """
        self.locker_reservations[locker_id].append((start_dt, end_dt))
        self.locker_reservations[locker_id].sort()

    def _get_ergonomic_score(self, height_level):
        """
        Calculates an ergonomic score based on the height level.
        Assumes middle height (3) is best, while too high (5) or too low (1) is worse.
        """
        if height_level == 3: return 5  # Highest score
        if height_level in [2, 4]: return 4
        if height_level in [1, 5]: return 2
        return 1 # Other unexpected cases

    def strawman_heuristic(self, demand_request):
        """
        a. Strawman Heuristic: A simple "First-Fit" strategy.
        
        Logic:
        1. Iterate through all lockers (already sorted by size, from smallest to largest).
        2. Find the first locker that is large enough and available for the requested time.
        3. If found, assign it immediately and return success. Otherwise, reject the request
           after checking all lockers.
        This algorithm is simple and fast but may lead to inefficient space usage
        (e.g., using a large locker for a small package).
        """
        self.processed_requests += 1
        req_start = demand_request['real_deposit_dt']
        req_end = demand_request['real_pickup_dt']
        req_size = demand_request['min_size_ft3']

        for _, locker in self.locker_bank.iterrows():
            if locker['size'] >= req_size:
                if self._is_available(locker['locker_id'], req_start, req_end):
                    self._assign_locker(locker['locker_id'], req_start, req_end)
                    self.accepted_requests += 1
                    return {"status": "Accepted", "locker_id": locker['locker_id'], "locker_size": locker['size']}

        self.rejected_requests += 1
        return {"status": "Rejected", "locker_id": None, "locker_size": None}

    def smarter_heuristic(self, demand_request):
        """
        b. Smarter Heuristic: "Best-Fit" + Ergonomics.
        
        Logic:
        1. Filter for all "candidate lockers" that are large enough and available
           during the requested time.
        2. If no candidates are found, reject the request.
        3. Determine the best candidate by applying criteria in order:
           a. Prioritize the locker with the minimum "wasted space"
              (locker['size'] - req_size). This is the "Best-Fit" part.
           b. If there's a tie (multiple lockers have the same minimal wasted space),
              select the one with the highest "ergonomic score" as the tie-breaker.
        """
        self.processed_requests += 1
        req_start = demand_request['real_deposit_dt']
        req_end = demand_request['real_pickup_dt']
        req_size = demand_request['min_size_ft3']

        # 1. Filter for candidate lockers
        candidates = []
        for _, locker in self.locker_bank.iterrows():
            if locker['size'] >= req_size and self._is_available(locker['locker_id'], req_start, req_end):
                candidates.append(locker)

        # 2. If no candidates are found, reject the request
        if not candidates:
            self.rejected_requests += 1
            return {"status": "Rejected", "locker_id": None, "locker_size": None}

        # 3. Find the best candidate
        best_candidate = None
        min_wasted_space = float('inf')
        max_ergo_score = -1

        for locker in candidates:
            wasted_space = locker['size'] - req_size
            ergo_score = self._get_ergonomic_score(locker['height_level'])

            # Prioritize minimizing wasted space
            if wasted_space < min_wasted_space:
                min_wasted_space = wasted_space
                max_ergo_score = ergo_score
                best_candidate = locker
            # If wasted space is the same, use ergonomics as a tie-breaker
            elif wasted_space == min_wasted_space:
                if ergo_score > max_ergo_score:
                    max_ergo_score = ergo_score
                    best_candidate = locker
        
        # If no single best candidate is found after the ergonomic check,
        # default to the first candidate with the minimum wasted space.
        if best_candidate is None:
            best_candidate = min(candidates, key=lambda l: l['size'] - req_size)

        # 4. Assign the locker
        self._assign_locker(best_candidate['locker_id'], req_start, req_end)
        self.accepted_requests += 1
        return {"status": "Accepted", "locker_id": best_candidate['locker_id'], "locker_size": best_candidate['size']}

# =============================================================================
# --- Demonstration of how to use the LockerAssignmentAgent ---
# =============================================================================
if __name__ == '__main__':
    # 1. Create a sample locker bank (simulating the output of Task 1)
    locker_data = {
        'locker_id': [1, 2, 3, 4, 5, 6],
        'size': [3.0, 3.0, 9.0, 9.0, 18.0, 18.0], # 2 small, 2 medium, 2 large
        'height_level': [1, 3, 2, 3, 1, 5]       # Includes various ergonomic levels
    }
    sample_locker_bank = pd.DataFrame(locker_data)
    print("--- Sample Locker Bank ---")
    print(sample_locker_bank)

    # 2. Create an assignment agent
    agent = LockerAssignmentAgent(sample_locker_bank)

    # 3. Create some sample demands (simulating the output of Task 3)
    start_time = datetime.datetime(2025, 10, 10, 9, 0, 0)
    sample_demands = [
        {'package_id': 1, 'min_size_ft3': 2.5, 'real_deposit_dt': start_time, 'real_pickup_dt': start_time + datetime.timedelta(hours=10)},
        {'package_id': 2, 'min_size_ft3': 8.0, 'real_deposit_dt': start_time + datetime.timedelta(hours=1), 'real_pickup_dt': start_time + datetime.timedelta(hours=12)},
        {'package_id': 3, 'min_size_ft3': 2.0, 'real_deposit_dt': start_time + datetime.timedelta(hours=2), 'real_pickup_dt': start_time + datetime.timedelta(hours=5)},
        {'package_id': 4, 'min_size_ft3': 10.0, 'real_deposit_dt': start_time + datetime.timedelta(hours=3), 'real_pickup_dt': start_time + datetime.timedelta(hours=20)},
        {'package_id': 5, 'min_size_ft3': 10.0, 'real_deposit_dt': start_time + datetime.timedelta(hours=4), 'real_pickup_dt': start_time + datetime.timedelta(hours=22)}, # This request might be rejected
    ]
    
    # 4. Process the demands using the "Smarter Heuristic"
    print("\n--- Processing Demands with Smarter Heuristic ---")
    for demand in sample_demands:
        result = agent.smarter_heuristic(demand)
        print(f"Request ID {demand['package_id']} (Size: {demand['min_size_ft3']}): "
              f"Status: {result['status']}, Locker ID: {result['locker_id']} (Size: {result['locker_size']})")

    # 5. Print the final statistics
    print("\n--- Final Statistics ---")
    service_level = (agent.accepted_requests / agent.processed_requests) * 100 if agent.processed_requests > 0 else 0
    print(f"Processed: {agent.processed_requests}, Accepted: {agent.accepted_requests}, Rejected: {agent.rejected_requests}")
    print(f"Service Level: {service_level:.2f}%")
