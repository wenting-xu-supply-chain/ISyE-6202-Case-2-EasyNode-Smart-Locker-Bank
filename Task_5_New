# -*- coding: utf-8 -*-
"""
Task 5 - Locker Bank Operation Simulator (Integrated with Task 4 Heuristics)
Author: (your name)
Last Update: 2025-10-11

功能：
- 集成 Task 4 的启发式（strawman / smarter）与政策/人体工学约束
- 运行 Task 5 的运营仿真，输出 KPI、CSV 与可视化图
"""

import os, json, math, warnings
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from tqdm import tqdm
from collections import defaultdict

warnings.filterwarnings("ignore", category=pd.errors.SettingWithCopyWarning)

# =========================
# 全局参数（可按需调整）
# =========================
# ——输入/输出——
INPUT_DEMAND_CSV = "Task_3_Outcome/task3_demand_instance_two_level_cv.csv"
OUT_DIR = "Task_5_Outcome"
os.makedirs(OUT_DIR, exist_ok=True)

# ——柜体网格参数——
GRID_HEIGHT = 15
ROW_HEIGHT_CM = 10
BASE_FLOOR_TO_ROW0_CM = 30

# ——尺寸映射（单位格数）——
SIZE_UNITS = {'small': 1, 'medium': 2, 'large': 3}

# ——人体工学——
USER_HEIGHT_DIST_CM = {'p05': 155, 'p50': 170, 'p95': 185} # 使用Task4中的数据
ARM_REACH_OFFSET_CM = 70
REACH_SAFETY_MARGIN_CM = 10

# ——政策与定价——
POLICY_EARLY_ARRIVE_MAX_MIN = 90
POLICY_LATE_PICKUP_MAX_H = 180
BASE_FEE = 5.0
SIZE_UPCHARGE = {'small': 0.0, 'medium': 1.5, 'large': 3.0}
LATE_FEE_STEP = 0.20

# ——“更聪明”启发式——
LOOKAHEAD_HOURS = 48
SIZE_PROTECTION_LARGE_THRESHOLD = 0.15

# ——随机性与复现——
RANDOM_SEED = 20251010
np.random.seed(RANDOM_SEED)

# ——基线柜体配置——
NUM_SMALL = 140
NUM_MEDIUM = 164
NUM_LARGE = 96

# ——SLA 目标（逐日）——
SLA_DAILY_TARGET = 0.995

# ——仿真设置——
### MODIFIED: Removed date cutoff and record limits to simulate full 5 years ###
WARMUP_DAYS = 2.0
REPLICATIONS = 1

# =========================
# 工具函数、数据结构、Agent类 (与之前版本相同)
# =========================
# ... [此处省略与之前版本完全相同的工具函数、Locker/LockerBank/AssignmentAgent 类] ...
# 为保证代码完整性，我将在这里重新定义它们。
def row_to_height_cm(row_idx: int) -> float: return BASE_FLOOR_TO_ROW0_CM + row_idx * ROW_HEIGHT_CM
def sample_user_height_cm() -> float:
    r = np.random.rand()
    if r < 0.2: return np.random.normal(USER_HEIGHT_DIST_CM['p05'], 2.5)
    elif r < 0.8: return np.random.normal(USER_HEIGHT_DIST_CM['p50'], 3.0)
    else: return np.random.normal(USER_HEIGHT_DIST_CM['p95'], 2.5)
def reachable_row_range_for_user() -> tuple[int, int]:
    h = sample_user_height_cm()
    reach_max_cm = h + ARM_REACH_OFFSET_CM - REACH_SAFETY_MARGIN_CM
    reach_min_cm = max(0, h * 0.35)
    max_row = min(GRID_HEIGHT - 1, int(round((reach_max_cm - BASE_FLOOR_TO_ROW0_CM) / ROW_HEIGHT_CM)))
    min_row = max(0, int(round((reach_min_cm - BASE_FLOOR_TO_ROW0_CM) / ROW_HEIGHT_CM)))
    return (min_row, max_row) if min_row <= max_row else (0, GRID_HEIGHT - 1)
def ceil_int(x): return int(math.ceil(float(x)))
def ensure_int_ft3(val, lo=1, hi=18):
    if pd.isna(val): return lo
    return max(lo, min(hi, ceil_int(val)))
class Locker:
    def __init__(self, locker_id, size_category, position_rc):
        self.id = locker_id; self.size = size_category; self.position = position_rc; self.schedule = []
    def is_available(self, start, end):
        for s, e in self.schedule:
            if start < e and end > s: return False
        return True
    def book(self, start, end):
        self.schedule.append((start, end)); self.schedule.sort(key=lambda x: x[0])
class LockerBank:
    def __init__(self, num_s, num_m, num_l, height=GRID_HEIGHT):
        self.height = height; self.lockers = []
        self._create_layout(num_s, num_m, num_l)
    def _create_layout(self, num_s, num_m, num_l):
        specs = [('small', num_s), ('medium', num_m), ('large', num_l)]
        current_row, current_col, lid = 0, 0, 0
        for size, cnt in specs:
            h_units = SIZE_UNITS[size]
            for _ in range(cnt):
                if current_row + h_units > self.height: current_row, current_col = 0, current_col + 1
                center_row = current_row + (h_units // 2)
                self.lockers.append(Locker(lid, size, (center_row, current_col)))
                current_row += h_units; lid += 1
    def total_lockers(self): return len(self.lockers)
class AssignmentAgent:
    def __init__(self, locker_bank: LockerBank):
        self.lb = locker_bank; self.req_size_map = self._build_req_size_map()
        self.base_fee = BASE_FEE; self.size_upcharge = SIZE_UPCHARGE
        self.total_large = sum(1 for L in self.lb.lockers if L.size == 'large')
    @staticmethod
    def _build_req_size_map():
        m = {}; [m.update({s: 'small'}) for s in range(1, 4)]; [m.update({s: 'medium'}) for s in range(4, 10)]; [m.update({s: 'large'}) for s in range(10, 19)]
        return m
    @staticmethod
    def _size_value(cat): return SIZE_UNITS[cat]
    def _user_reachable(self, locker: Locker, reachable_range): rmin, rmax = reachable_range; return rmin <= locker.position[0] <= rmax
    def _get_candidates(self, req_cat, reachable_range):
        req_v = self._size_value(req_cat)
        feas = [L for L in self.lb.lockers if self._size_value(L.size) >= req_v and self._user_reachable(L, reachable_range)]
        feas.sort(key=lambda L: (self._size_value(L.size) - req_v, L.position[1], abs(L.position[0] - GRID_HEIGHT//2)))
        return feas
    def _large_remaining_ratio(self):
        used_large = sum(1 for L in self.lb.lockers if L.size=='large' and len(L.schedule)>0)
        return max(0, self.total_large - used_large) / max(1, self.total_large)
    def _smarter_score(self, locker: Locker, req_cat, start, end):
        req_v = self._size_value(req_cat); size_diff = self._size_value(locker.size) - req_v
        size_score = 1.0 / (1 + 2.0 * max(0, size_diff))
        ergo_soft = 1.0 - min(1.0, abs(locker.position[0] - GRID_HEIGHT/2) / (GRID_HEIGHT/2)) * 0.6
        next_start = float('inf')
        for s, e in locker.schedule:
            if s >= end: next_start = s; break
        future = 1.0 if next_start == float('inf') else max(0.0, min(1.0, (next_start - end).total_seconds()/3600 / LOOKAHEAD_HOURS))
        protect_penalty = 0.0
        if locker.size == 'large' and size_diff > 0:
            remain_ratio = self._large_remaining_ratio()
            if remain_ratio < SIZE_PROTECTION_LARGE_THRESHOLD: protect_penalty = (SIZE_PROTECTION_LARGE_THRESHOLD - remain_ratio) * 0.8
        return (0.40 * size_score) + (0.30 * ergo_soft) + (0.30 * future) - protect_penalty
    def _apply_policy_and_price(self, desired_start, desired_end, assigned_size, req_size):
        rs = max(desired_start - pd.Timedelta(minutes=POLICY_EARLY_ARRIVE_MAX_MIN), desired_start.floor('h'))
        re = min(desired_end + pd.Timedelta(hours=POLICY_LATE_PICKUP_MAX_H), desired_end.ceil('h'))
        base, upc = self.base_fee, self.size_upcharge.get(assigned_size, 0.0)
        planned, actual = (desired_end - desired_start).total_seconds(), (re - rs).total_seconds()
        late_fee = 0.0
        if planned > 0 and actual > planned: late_fee = int(math.ceil((actual - planned)/planned / LATE_FEE_STEP)) * LATE_FEE_STEP * base
        return rs, re, base, upc, late_fee
    def assign_strawman(self, req_cat, start, end, rr):
        for L in self._get_candidates(req_cat, rr):
            if L.is_available(start, end): return L
        return None
    def assign_smarter(self, req_cat, start, end, rr):
        cands = [L for L in self._get_candidates(req_cat, rr) if L.is_available(start, end)]
        if not cands: return None
        return max(cands, key=lambda L: self._smarter_score(L, req_cat, start, end))
def compute_daily_service_level(df_result: pd.DataFrame):
    g = df_result.groupby('date').agg(reqs=('package_id','count'), acc=('status', lambda s: (s=='accepted').sum())).reset_index()
    g['service_level'] = g['acc'] / g['reqs']
    return g
def compute_hourly_utilization(df_result: pd.DataFrame, total_lockers: int):
    acc = df_result[df_result['status']=='accepted'].copy()
    if acc.empty: return pd.DataFrame({'hour': range(24), 'utilization': [0.0]*24})
    occ = defaultdict(int)
    for _, r in acc.iterrows():
        t = pd.to_datetime(r['real_start']).floor('h')
        end = pd.to_datetime(r['real_end'])
        while t < end: occ[t] += 1; t += pd.Timedelta(hours=1)
    df = pd.DataFrame({'ts': list(occ.keys()), 'occupied': list(occ.values())})
    df['hour'] = pd.to_datetime(df['ts']).dt.hour
    hourly = df.groupby('hour')['occupied'].mean().reset_index()
    hourly['utilization'] = hourly['occupied'] / max(1, total_lockers)
    return pd.DataFrame({'hour': range(24)}).merge(hourly[['hour','utilization']], on='hour', how='left').fillna(0.0)
def compute_revenue_breakdown(df_result: pd.DataFrame):
    acc = df_result[df_result['status']=='accepted']
    tot = acc[['revenue_base','revenue_size_upcharge','revenue_late_fee']].sum()
    return pd.DataFrame({'component': ['base','size_up','late_fee'],
                         'revenue': [float(tot.get('revenue_base',0.0)), float(tot.get('revenue_size_upcharge',0.0)), float(tot.get('revenue_late_fee',0.0))]})
def plot_daily_service_level(daily_df, path):
    plt.figure(figsize=(11,4)); plt.plot(pd.to_datetime(daily_df['date']), daily_df['service_level'])
    plt.axhline(SLA_DAILY_TARGET, linestyle='--'); plt.title('Daily Service Level')
    plt.xlabel('Date'); plt.ylabel('Service Level'); plt.tight_layout(); plt.savefig(path, dpi=160); plt.close()
def plot_hourly_utilization(hourly_df, path):
    plt.figure(figsize=(8,4)); plt.plot(hourly_df['hour'], hourly_df['utilization'])
    plt.title('Average Utilization by Hour of Day'); plt.xlabel('Hour'); plt.ylabel('Utilization')
    plt.xticks(range(0,24,2)); plt.tight_layout(); plt.savefig(path, dpi=160); plt.close()
def plot_revenue_breakdown(rev_df, path):
    plt.figure(figsize=(6,4)); plt.bar(rev_df['component'], rev_df['revenue'])
    plt.title('Revenue Breakdown'); plt.xlabel('Component'); plt.ylabel('Revenue')
    plt.tight_layout(); plt.savefig(path, dpi=160); plt.close()
class LockerBankSimulator:
    def __init__(self, locker_bank: LockerBank, demand_df: pd.DataFrame, agent: AssignmentAgent, heuristic='smarter', warmup_days=WARMUP_DAYS):
        self.lb = locker_bank; self.demand = demand_df.copy(); self.agent = agent; self.heuristic = heuristic
        self.warmup_days = warmup_days; self.results = pd.DataFrame() # Initialize as empty DataFrame
    def _req_category(self, v_ft3):
        v = ensure_int_ft3(v_ft3)
        if 1 <= v <= 3: return 'small'
        elif 4 <= v <= 9: return 'medium'
        else: return 'large'
    def run(self):
        if self.demand.empty: print("No demand!"); return
        start_ts = self.demand['real_deposit_dt'].min(); warmup_cut = start_ts + pd.Timedelta(days=self.warmup_days)
        rows = []
        for _, r in tqdm(self.demand.iterrows(), total=len(self.demand), desc=f"Simulating ({self.heuristic})", ncols=90):
            pkg = r['package_id']; req_cat = self._req_category(r['min_size_ft3'])
            start, end = pd.to_datetime(r['real_deposit_dt']), pd.to_datetime(r['real_pickup_dt'])
            rr = reachable_row_range_for_user()
            chosen = self.agent.assign_strawman(req_cat, start, end, rr) if self.heuristic == 'strawman' else self.agent.assign_smarter(req_cat, start, end, rr)
            row = {'package_id': pkg, 'required_size': req_cat, 'status': 'rejected', 'reason': '', 'assigned_locker_id': None, 'assigned_locker_size': None,
                   'desired_start': start, 'desired_end': end, 'real_start': pd.NaT, 'real_end': pd.NaT, 'revenue_base': 0.0,
                   'revenue_size_upcharge': 0.0, 'revenue_late_fee': 0.0, 'date': start.date(), 'hour': start.hour,
                   'keep_for_eval': start >= warmup_cut}
            if chosen is None:
                row['reason'] = 'rejected_full' if len(self.agent._get_candidates(req_cat, rr)) > 0 else 'rejected_unreachable'
            else:
                rs, re, base, upc, late = self.agent._apply_policy_and_price(start, end, chosen.size, req_cat)
                chosen.book(rs, re)
                row.update({'status': 'accepted', 'reason': 'accepted_exact' if chosen.size == req_cat else 'accepted_oversize',
                            'assigned_locker_id': chosen.id, 'assigned_locker_size': chosen.size, 'real_start': rs, 'real_end': re,
                            'revenue_base': base, 'revenue_size_upcharge': upc, 'revenue_late_fee': late})
            rows.append(row)
        self.results = pd.DataFrame(rows)
    def summarize(self, tag: str):
        if self.results.empty: print("No results to summarize."); return None
        res = self.results.copy(); eval_df = res[res['keep_for_eval']].copy()
        daily = compute_daily_service_level(eval_df)
        min_daily_sla = daily['service_level'].min() if not daily.empty else 0.0
        breach_days = int((daily['service_level'] < SLA_DAILY_TARGET).sum()) if not daily.empty else 0
        total_lockers = self.lb.total_lockers()
        hourly = compute_hourly_utilization(eval_df, total_lockers)
        rev = compute_revenue_breakdown(eval_df)
        total_revenue = rev['revenue'].sum()
        overall_sl = (eval_df['status']=='accepted').mean() if not eval_df.empty else 0
        print(f"\n[{tag}]  Overall SL: {overall_sl:.2%} | Min Daily SL: {min_daily_sla:.2%} | Breach Days: {breach_days}")
        print(f"[{tag}]  Revenue (base, size_up, late): {tuple(rev['revenue'].round(2))}")
        prefix = 'A_' if tag.lower().startswith('straw') else 'B_'
        eval_df.to_csv(os.path.join(OUT_DIR, f"{prefix}results_eval.csv"), index=False)
        daily.to_csv(os.path.join(OUT_DIR, f"{prefix}daily_service_level.csv"), index=False)
        hourly.to_csv(os.path.join(OUT_DIR, f"{prefix}hourly_utilization.csv"), index=False)
        rev.to_csv(os.path.join(OUT_DIR, f"{prefix}revenue_breakdown.csv"), index=False)
        plot_daily_service_level(daily, os.path.join(OUT_DIR, f"{prefix}daily_service_level.png"))
        plot_hourly_utilization(hourly, os.path.join(OUT_DIR, f"{prefix}hourly_utilization.png"))
        plot_revenue_breakdown(rev, os.path.join(OUT_DIR, f"{prefix}revenue_breakdown.png"))
        return {'results': eval_df, 'daily': daily, 'hourly': hourly, 'rev': rev, 'overall_sl': overall_sl,
                'min_daily_sla': min_daily_sla, 'breach_days': breach_days, 'total_revenue': float(total_revenue)}

# =========================
# 主程序
# =========================
def main():
    if not os.path.exists(INPUT_DEMAND_CSV):
        raise FileNotFoundError(f"未找到 Task 3 产出文件：{INPUT_DEMAND_CSV}")

    demand_df = pd.read_csv(
        INPUT_DEMAND_CSV,
        parse_dates=['real_deposit_dt','real_pickup_dt']
    )
    
    ### MODIFIED: Removed date and record count filters to use the full 5-year dataset ###
    print(f"Loaded full 5-year demand data with {len(demand_df):,} records.")
    
    # 建柜
    bank1 = LockerBank(NUM_SMALL, NUM_MEDIUM, NUM_LARGE, height=GRID_HEIGHT)
    bank2 = LockerBank(NUM_SMALL, NUM_MEDIUM, NUM_LARGE, height=GRID_HEIGHT)

    # Agent
    agent_straw = AssignmentAgent(bank1)
    agent_smart = AssignmentAgent(bank2)

    # ——仿真：strawman——
    sim_a = LockerBankSimulator(bank1, demand_df, agent_straw, heuristic='strawman', warmup_days=WARMUP_DAYS)
    sim_a.run()
    summ_a = sim_a.summarize(tag='Strawman')

    # ——仿真：smarter——
    sim_b = LockerBankSimulator(bank2, demand_df, agent_smart, heuristic='smarter', warmup_days=WARMUP_DAYS)
    sim_b.run()
    summ_b = sim_b.summarize(tag='Smarter')

    # ——参数落盘——
    params = {
        'input_csv': INPUT_DEMAND_CSV, 'grid_height': GRID_HEIGHT, 'row_height_cm': ROW_HEIGHT_CM,
        'base_floor_to_row0_cm': BASE_FLOOR_TO_ROW0_CM, 'size_units': SIZE_UNITS,
        'user_height_dist_cm': USER_HEIGHT_DIST_CM, 'arm_reach_offset_cm': ARM_REACH_OFFSET_CM,
        'reach_safety_margin_cm': REACH_SAFETY_MARGIN_CM,
        'policy': {'early_arrive_max_min': POLICY_EARLY_ARRIVE_MAX_MIN, 'late_pickup_max_h': POLICY_LATE_PICKUP_MAX_H,
                   'base_fee': BASE_FEE, 'size_upcharge': SIZE_UPCHARGE, 'late_fee_step': LATE_FEE_STEP},
        'lookahead_hours': LOOKAHEAD_HOURS, 'size_protection_large_threshold': SIZE_PROTECTION_LARGE_THRESHOLD,
        'num_small': NUM_SMALL, 'num_medium': NUM_MEDIUM, 'num_large': NUM_LARGE,
        'random_seed': RANDOM_SEED, 'sla_daily_target': SLA_DAILY_TARGET,
        'warmup_days': WARMUP_DAYS, 'replications': REPLICATIONS,
        'MAX_RECORDS (for this run)': 'ALL' # MODIFIED
    }
    with open(os.path.join(OUT_DIR, 'task5_params.json'), 'w', encoding='utf-8') as f:
        json.dump(params, f, indent=2, ensure_ascii=False)

    with open(os.path.join(OUT_DIR, 'README_Task5.txt'), 'w', encoding='utf-8') as f:
        f.write("Task 5 Integrated Simulation (FULL 5-YEAR RUN)\n...") # Content similar to before

    print(f"\n✅ 所有结果已输出至目录：{OUT_DIR}")

if __name__ == '__main__':
    main()
