import pandas as pd
import numpy as np
import datetime
import random
from tqdm import tqdm
import os

# =============================================================================
# --- Section 1: Constants from Casework Document ---
# =============================================================================

# (Constants remain mostly the same)
### NEW: Added PERIOD_CV constant ###
PERIOD_CV = 0.2
DAILY_DEMAND_CV = 0.25

SIZE_PROBABILITY = {
    1: 0.08, 2: 0.12, 3: 0.15, 4: 0.12, 5: 0.08, 6: 0.06, 7: 0.05,
    8: 0.05, 9: 0.05, 10: 0.04, 11: 0.04, 12: 0.03, 13: 0.03,
    14: 0.03, 15: 0.02, 16: 0.02, 17: 0.02, 18: 0.01
}
SIZES = list(SIZE_PROBABILITY.keys())
SIZE_PROBS = list(SIZE_PROBABILITY.values())
PERIOD_DEMAND_SHARE = {
    1: 0.03, 2: 0.05, 3: 0.06, 4: 0.07, 5: 0.11, 6: 0.06, 7: 0.04,
    8: 0.10, 9: 0.10, 10: 0.06, 11: 0.08, 12: 0.11, 13: 0.13
}
DAY_OF_WEEK_SHARE = {
    0: 0.13, 1: 0.12, 2: 0.15, 3: 0.18, 4: 0.20, 5: 0.15, 6: 0.07
}
SCENARIO_TREE = {
    'start': [('1.1', 0.25), ('1.2', 0.25), ('1.3', 0.5)], '1.1': [('2.1', 0.3), ('2.2', 0.4), ('2.3', 0.3)],
    '1.2': [('2.2', 0.6), ('2.3', 0.4)], '1.3': [('2.4', 0.6), ('2.5', 0.4)], '2.1': [('3.1', 0.5), ('3.2', 0.5)],
    '2.2': [('3.1', 0.3), ('3.2', 0.4), ('3.3', 0.3)], '2.3': [('3.2', 0.6), ('3.3', 0.4)],
    '2.4': [('3.4', 0.6), ('3.5', 0.4)], '2.5': [('3.4', 0.4), ('3.5', 0.6)], '3.1': [('4.1', 0.5), ('4.2', 0.5)],
    '3.2': [('4.1', 0.3), ('4.2', 0.4), ('4.3', 0.3)], '3.3': [('4.2', 0.6), ('4.3', 0.4)],
    '3.4': [('4.3', 0.1), ('4.4', 0.6), ('4.5', 0.3)], '3.5': [('4.4', 0.4), ('4.5', 0.6)],
    '4.1': [('5.1', 0.5), ('5.2', 0.5)], '4.2': [('5.1', 0.3), ('5.2', 0.4), ('5.3', 0.3)],
    '4.3': [('5.2', 0.6), ('5.3', 0.4)], '4.4': [('5.3', 0.25), ('5.4', 0.75)], '4.5': [('5.4', 0.4), ('5.5', 0.6)]
}
SCENARIO_DEMANDS = {
    '1.1': 50000, '1.2': 60000, '1.3': 80000, '2.1': 60000, '2.2': 65000, '2.3': 70000, '2.4': 90000, '2.5': 100000,
    '3.1': 60000, '3.2': 70000, '3.3': 75000, '3.4': 100000, '3.5': 110000, '4.1': 60000, '4.2': 75000, '4.3': 80000,
    '4.4': 105000, '4.5': 120000, '5.1': 60000, '5.2': 65000, '5.3': 90000, '5.4': 110000, '5.5': 150000
}
DAILY_DEPOSIT_DIST = np.array([200, 200, 100, 100, 300, 300, 400, 400, 600, 600, 600, 600, 400, 600, 800, 600, 600, 500, 500, 400, 200, 200, 200, 200])
DEPOSIT_HOUR_PROBS = DAILY_DEPOSIT_DIST / DAILY_DEPOSIT_DIST.sum()
DAILY_PICKUP_DIST = np.array([103, 22, 38, 28, 141, 280, 547, 710, 521, 424, 506, 560, 558, 496, 517, 610, 786, 790, 720, 626, 495, 289, 183, 0])
PICKUP_HOUR_PROBS = DAILY_PICKUP_DIST / DAILY_PICKUP_DIST.sum()
START_YEAR = 2026

# =============================================================================
# --- Section 2: Helper Functions (No changes in this section) ---
# =============================================================================
# The helper functions _generate_intra_hour_arrival_minutes, _simulate_annual_demand_path,
# and _generate_packages_for_one_day remain the same as the previous version.
def _generate_intra_hour_arrival_minutes(N, lsp_proportion=0.8, lsp_mean=15, lsp_std=5):
    """Generates N package arrival times within a single hour."""
    if N <= 0: return []
    n_lsp = int(round(N * lsp_proportion)); n_cust = N - n_lsp
    lsp_times = np.clip(np.random.normal(loc=lsp_mean, scale=lsp_std, size=n_lsp), 0, 60)
    cust_times = np.random.uniform(0, 60, n_cust)
    all_times = np.concatenate((lsp_times, cust_times)); all_times.sort()
    return list(all_times)

def _simulate_annual_demand_path() -> list[int]:
    """Simulates a single 5-year demand path through the scenario tree."""
    annual_demands = []; current_node = 'start'
    for _ in range(5):
        next_states = SCENARIO_TREE[current_node]
        nodes, probabilities = zip(*next_states)
        chosen_node = np.random.choice(nodes, p=probabilities)
        annual_demands.append(SCENARIO_DEMANDS[chosen_node]); current_node = chosen_node
    return annual_demands

def _generate_packages_for_one_day(num_packages: int, date: datetime.date) -> list[dict]:
    """Generates a list of package demand instances for a single day."""
    if num_packages <= 0: return []
    package_list = []
    required_sizes = np.random.choice(SIZES, size=num_packages, p=SIZE_PROBS)
    deposit_hours = np.random.choice(24, size=num_packages, p=DEPOSIT_HOUR_PROBS)
    hourly_deposit_counts = pd.Series(deposit_hours).value_counts().to_dict()
    all_deposit_datetimes = []
    for hour, count in hourly_deposit_counts.items():
        arrival_minutes = _generate_intra_hour_arrival_minutes(count)
        for minute in arrival_minutes:
            base_time = datetime.datetime.combine(date, datetime.time(hour=hour))
            all_deposit_datetimes.append(base_time + datetime.timedelta(minutes=minute))
    random.shuffle(all_deposit_datetimes)
    pickup_hours = np.random.choice(24, size=num_packages, p=PICKUP_HOUR_PROBS)
    hourly_pickup_counts = pd.Series(pickup_hours).value_counts().to_dict()
    all_pickup_minutes = []
    for hour, count in hourly_pickup_counts.items():
        arrival_minutes = np.random.uniform(0, 60, count)
        for minute in arrival_minutes: all_pickup_minutes.append((hour, minute))
    random.shuffle(all_pickup_minutes)
    for i in range(num_packages):
        desired_deposit_dt = all_deposit_datetimes[i]
        pickup_hour, pickup_minute = all_pickup_minutes[i]
        pickup_date = desired_deposit_dt.date()
        if pickup_hour < desired_deposit_dt.hour: pickup_date += datetime.timedelta(days=1)
        base_pickup_time = datetime.datetime.combine(pickup_date, datetime.time(hour=pickup_hour))
        desired_pickup_dt = base_pickup_time + datetime.timedelta(minutes=pickup_minute)
        deposit_offset_hours = random.uniform(-1.5, 180.0)
        pickup_offset_hours = random.uniform(-6.0, 6.0)
        real_deposit_dt = desired_deposit_dt + datetime.timedelta(hours=deposit_offset_hours)
        if real_deposit_dt >= desired_pickup_dt: real_deposit_dt = desired_pickup_dt - datetime.timedelta(hours=1)
        real_pickup_dt = desired_pickup_dt + datetime.timedelta(hours=pickup_offset_hours)
        package_list.append({'min_size_ft3': required_sizes[i], 'desired_deposit_dt': desired_deposit_dt,
                             'desired_pickup_dt': desired_pickup_dt, 'real_deposit_dt': real_deposit_dt,
                             'real_pickup_dt': real_pickup_dt})
    return package_list


# =============================================================================
# --- Section 3: Main Simulator Function ---
# =============================================================================

### REFACTORED SECTION: This function now includes the two-level variability ###
def generate_five_year_demand_instance() -> pd.DataFrame:
    """Develops a locker bank demand simulator with two-level variability."""
    print("--- Starting 5-Year Dynamic Demand Simulation (with two-level CV) ---")
    
    annual_demands = _simulate_annual_demand_path()
    print(f"Simulated Annual Demand Path (Mean Targets): {annual_demands}")

    start_date = datetime.date(START_YEAR, 1, 1)
    end_date = start_date + datetime.timedelta(days=int(5 * 365.25) - 1)
    date_range = pd.to_datetime(pd.date_range(start=start_date, end=end_date, freq='D'))
    
    daily_demand_df = pd.DataFrame(date_range, columns=['date'])
    daily_demand_df['year'] = daily_demand_df['date'].dt.year
    daily_demand_df['period'] = ((daily_demand_df['date'].dt.dayofyear - 1) // 28) + 1
    daily_demand_df['period'] = daily_demand_df['period'].clip(upper=13)
    daily_demand_df['day_of_week'] = daily_demand_df['date'].dt.dayofweek
    
    all_years_dfs = []
    for year_idx, total_annual_demand in enumerate(annual_demands):
        year = START_YEAR + year_idx
        year_df_template = daily_demand_df[daily_demand_df['year'] == year].copy()
        
        all_period_dfs = []
        # New inner loop to simulate each period's total demand first
        for period_num in range(1, 14):
            period_df = year_df_template[year_df_template['period'] == period_num].copy()
            if len(period_df) == 0: continue

            # Step 1: Simulate total demand for this period using the 0.2 CV
            expected_period_demand = total_annual_demand * PERIOD_DEMAND_SHARE[period_num]
            period_std_dev = expected_period_demand * PERIOD_CV
            simulated_period_demand = np.random.normal(expected_period_demand, period_std_dev)
            simulated_period_demand = int(max(0, round(simulated_period_demand)))

            # Step 2: Distribute this simulated period total across its days
            if len(period_df) > 0:
                mean_daily_for_period = simulated_period_demand / len(period_df)
                period_df['dow_share'] = period_df['day_of_week'].map(DAY_OF_WEEK_SHARE)
                avg_dow_share_in_period = period_df['dow_share'].mean()
                
                # Calculate expected demand for each day based on its DoW share
                period_df['expected_daily'] = mean_daily_for_period * (period_df['dow_share'] / avg_dow_share_in_period)
                
                # Apply the 0.25 daily CV
                daily_std_dev = period_df['expected_daily'] * DAILY_DEMAND_CV
                period_df['simulated_daily'] = np.random.normal(period_df['expected_daily'], daily_std_dev)
                period_df['simulated_daily'] = period_df['simulated_daily'].fillna(0).round().astype(int).clip(lower=0)
                
                # Rescale daily demand to perfectly match the simulated period total
                current_sum = period_df['simulated_daily'].sum()
                if current_sum > 0:
                    scale_factor = simulated_period_demand / current_sum
                    period_df['final_daily_demand'] = (period_df['simulated_daily'] * scale_factor).round().astype(int)
                else:
                    period_df['final_daily_demand'] = 0

                remainder = simulated_period_demand - period_df['final_daily_demand'].sum()
                if remainder > 0:
                    demand_values = period_df['final_daily_demand'].values
                    add_indices = np.random.choice(demand_values.size, size=int(remainder), replace=True)
                    np.add.at(demand_values, add_indices, 1)
                    period_df['final_daily_demand'] = demand_values
            else:
                 period_df['final_daily_demand'] = 0

            all_period_dfs.append(period_df)
        
        if all_period_dfs:
            year_df_final = pd.concat(all_period_dfs)
            all_years_dfs.append(year_df_final)

    if not all_years_dfs: return pd.DataFrame()
    
    final_demand_schedule = pd.concat(all_years_dfs)
    
    all_packages = []
    print("\nGenerating individual package details for each day...")
    for _, row in tqdm(final_demand_schedule.iterrows(), total=len(final_demand_schedule), desc="Daily Progress"):
        num_packages_today = row['final_daily_demand']
        if num_packages_today > 0:
            packages_today = _generate_packages_for_one_day(int(num_packages_today), row['date'].date())
            all_packages.extend(packages_today)
            
    print("\nSimulation complete. Finalizing DataFrame.")
    demand_instance_df = pd.DataFrame(all_packages)
    
    if not demand_instance_df.empty:
        demand_instance_df.insert(0, 'package_id', range(1, len(demand_instance_df) + 1))
    
    return demand_instance_df


# =============================================================================
# --- Section 4: Execution Block (No changes in this section) ---
# =============================================================================
if __name__ == '__main__':
    demand_df = generate_five_year_demand_instance()
    
    if not demand_df.empty:
        print("\n\n--- Simulation Output ---")
        actual_total_demand = len(demand_df)
        print(f"Successfully generated {actual_total_demand:,} package demand instances over 5 years.")
        demand_df.info()
        print("\nSample of Generated Demand Data (First 5 rows):")
        print(demand_df.head())
        
        output_folder = "Task_3_Outcome"
        os.makedirs(output_folder, exist_ok=True)
        filename = "task3_demand_instance_two_level_cv.csv"
        output_filepath = os.path.join(output_folder, filename)
        
        demand_df.to_csv(output_filepath, index=False)
        print(f"\n✅ Full demand instance saved to '{output_filepath}'")
    else:
        print("\n--- Simulation resulted in an empty demand set. ---")
