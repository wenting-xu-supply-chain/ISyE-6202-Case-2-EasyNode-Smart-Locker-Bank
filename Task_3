# -*- coding: utf-8 -*-
"""
Task 4 - Dynamic Assignment Simulation with Ergonomics, Policy & Visualization
Author: (your name)
Last Update: 2025-10-10

功能概述：
1) 两种启发式分配：strawman（先到先分）、smarter（评分：尺寸匹配+人体工学+前瞻+尺寸保护）
2) 人体工学约束：基于“人群身高分布+行高映射”的可达区间（硬约束），并在评分中作为软偏好
3) 政策实现：最早提前 90 分钟、最晚延后 180 小时；仅大柜可用时收差价；晚取每超 20% 收 20% 附加费
4) 绩效输出：每日服务水平(需≥99.5%)、小时利用率、收入(基础+差价+滞纳)分解
5) 可视化：三张图自动保存；结果 CSV/参数 JSON/简要 README 自动保存

使用：
python task4_sim.py
"""

import os
import json
import math
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from tqdm import tqdm
from collections import defaultdict

# =========================
# 全局参数（可按需调整）
# =========================

# ——柜体网格参数——
GRID_HEIGHT = 15                 # 垂直方向行数
ROW_HEIGHT_CM = 10               # 每“行”的近似高度（cm），用于人体工学映射
BASE_FLOOR_TO_ROW0_CM = 30       # 地面到第 0 行中线的基准高度（cm）

# ——尺寸映射（单位格数）——
SIZE_UNITS = {'small': 1, 'medium': 2, 'large': 3}

# ——人体工学（简单身高分布三分位，仅示例，可替换为更贴近数据的分布）——
USER_HEIGHT_DIST_CM = {'p05': 155, 'p50': 170, 'p95': 185}  # 成年人身高三分位
ARM_REACH_OFFSET_CM = 70   # 肩到指尖近似，影响可达上界
REACH_SAFETY_MARGIN_CM = 10  # 安全裕度，避免极限姿态

# ——政策与定价（示例数值，可按案例要求修正）——
POLICY_EARLY_ARRIVE_MAX_MIN = 90            # 最早可提前 90 分钟
POLICY_LATE_PICKUP_MAX_H = 180              # 最晚可延后 180 小时
BASE_FEE = 5.0                              # 基础使用费（任意币值）
SIZE_UPCHARGE = {'small': 0.0, 'medium': 1.5, 'large': 3.0}  # 尺寸附加价（按分配柜尺寸）
LATE_FEE_STEP = 0.20                        # 每超 20% 收 20%
SIZE_PROTECTION_LARGE_THRESHOLD = 0.15      # 大柜剩余占比阈值（保护大柜资源）
LOOKAHEAD_HOURS = 48                        # 前瞻窗口，用于评分

# ——随机性与复现——
RANDOM_SEED = 42
np.random.seed(RANDOM_SEED)

# ——输入/输出——
INPUT_DEMAND_CSV = "Task_3_Outcome/task3_demand_instance_highest_mode.csv"
OUTPUT_DIR = "Task_4_Outcome"
os.makedirs(OUTPUT_DIR, exist_ok=True)

# ——基线柜体配置（可调整/可从 Task 1 计算结果读取）——
NUM_SMALL = 140
NUM_MEDIUM = 164
NUM_LARGE = 96


# =========================
# 工具函数
# =========================

def row_to_height_cm(row_idx: int) -> float:
    """将行号映射为高度(相对于地面)，取该行“中线”高度。"""
    return BASE_FLOOR_TO_ROW0_CM + row_idx * ROW_HEIGHT_CM

def sample_user_height_cm() -> float:
    """简单三分位混合抽样（5%、50%、95%），用于示意。"""
    r = np.random.rand()
    if r < 0.2:
        # 偏矮
        return np.random.normal(USER_HEIGHT_DIST_CM['p05'], 2.5)
    elif r < 0.8:
        # 中位
        return np.random.normal(USER_HEIGHT_DIST_CM['p50'], 3.0)
    else:
        # 偏高
        return np.random.normal(USER_HEIGHT_DIST_CM['p95'], 2.5)

def reachable_row_range_for_user() -> tuple[int, int]:
    """根据用户身高粗略计算可达行区间（含安全裕度）。"""
    h = sample_user_height_cm()
    # 简化：可达上界 ~ 肩高+臂展的一部分；可达下界 ~ 蹲/弯腰可达，但给安全裕度
    reach_max_cm = h + ARM_REACH_OFFSET_CM - REACH_SAFETY_MARGIN_CM
    reach_min_cm = max(0, h * 0.35)  # 低位可达（极简化），避免过低的不适
    # 将高度映射成行号
    max_row = int(round((reach_max_cm - BASE_FLOOR_TO_ROW0_CM) / ROW_HEIGHT_CM))
    min_row = int(round((reach_min_cm - BASE_FLOOR_TO_ROW0_CM) / ROW_HEIGHT_CM))
    # 夹紧到 [0, GRID_HEIGHT-1]
    min_row = max(0, min_row)
    max_row = min(GRID_HEIGHT - 1, max_row)
    if min_row > max_row:
        # 极端异常，退化为全可达（不常见）
        return 0, GRID_HEIGHT - 1
    return min_row, max_row

def ceil_int(x):
    return int(math.ceil(float(x)))

def ensure_int_ft3(val, lo=1, hi=18):
    """将 min_size_ft3（可能为浮点/缺失）转换为 1..18 的整数区间。"""
    if pd.isna(val):
        return lo
    v = ceil_int(val)
    return max(lo, min(hi, v))


# =========================
# 数据结构
# =========================

class Locker:
    def __init__(self, locker_id, size_category, position_rc):
        self.id = locker_id
        self.size = size_category              # 'small'/'medium'/'large'
        self.position = position_rc            # (row, col)
        self.schedule = []                     # [(start, end), ...]

    def is_available(self, start, end):
        for s, e in self.schedule:
            # overlap: start<e & end>s
            if start < e and end > s:
                return False
        return True

    def book(self, start, end):
        self.schedule.append((start, end))
        self.schedule.sort(key=lambda x: x[0])


class LockerBank:
    """顺序堆叠布局（列满则换列）。"""
    def __init__(self, num_s, num_m, num_l, height=GRID_HEIGHT):
        self.height = height
        self.lockers = []
        self._create_layout(num_s, num_m, num_l)

    def _create_layout(self, num_s, num_m, num_l):
        specs = [('small', num_s), ('medium', num_m), ('large', num_l)]
        current_row, current_col = 0, 0
        lid = 0
        for size, cnt in specs:
            h_units = SIZE_UNITS[size]
            for _ in range(cnt):
                if current_row + h_units > self.height:
                    current_row = 0
                    current_col += 1
                # 以“中线行号”近似
                center_row = current_row + (h_units // 2)
                self.lockers.append(Locker(lid, size, (center_row, current_col)))
                current_row += h_units
                lid += 1

    def total_lockers(self):
        return len(self.lockers)

    def count_by_size(self):
        c = defaultdict(int)
        for L in self.lockers:
            c[L.size] += 1
        return dict(c)


# =========================
# 核心 Agent
# =========================

class AssignmentAgent:
    def __init__(self, locker_bank: LockerBank, demand_df: pd.DataFrame):
        self.lb = locker_bank
        # 只保留仿真需要的字段，排序
        self.df = (
            demand_df[['package_id', 'min_size_ft3', 'real_deposit_dt', 'real_pickup_dt']]
            .copy()
            .dropna(subset=['real_deposit_dt', 'real_pickup_dt'])
            .sort_values(by='real_deposit_dt')
            .reset_index(drop=True)
        )
        # 需求体积 -> 尺寸类别
        self.req_size_map = self._build_req_size_map()
        # 定价
        self.base_fee = BASE_FEE
        self.size_upcharge = SIZE_UPCHARGE

        # 尺寸保护所需统计
        self.total_large = sum(1 for L in self.lb.lockers if L.size == 'large')

    @staticmethod
    def _build_req_size_map():
        """1–3->small, 4–9->medium, 10–18->large"""
        m = {}
        for s in range(1, 4): m[s] = 'small'
        for s in range(4, 10): m[s] = 'medium'
        for s in range(10, 19): m[s] = 'large'
        return m

    def _req_category(self, min_size_ft3):
        v = ensure_int_ft3(min_size_ft3)
        return self.req_size_map[v]

    @staticmethod
    def _size_value(cat):
        return SIZE_UNITS[cat]

    def _user_reachable(self, locker: Locker, reachable_range):
        rmin, rmax = reachable_range
        return rmin <= locker.position[0] <= rmax

    def _get_candidates(self, req_cat, reachable_range):
        """按可行尺寸优先级排序：正好尺寸 -> 更大尺寸；并过滤不可达柜位。"""
        req_v = self._size_value(req_cat)
        feas = [L for L in self.lb.lockers if self._size_value(L.size) >= req_v and self._user_reachable(L, reachable_range)]
        # 排序：尺寸越接近越优；其次列号小优先（减少走动）；再次行号靠中间优先
        feas.sort(key=lambda L: (self._size_value(L.size) - req_v, L.position[1], abs(L.position[0] - GRID_HEIGHT//2)))
        return feas

    def _apply_policy(self, desired_start, desired_end, assigned_size, req_size):
        """返回 (real_start, real_end, base, size_up, late_fee)"""
        # 边界裁剪
        real_start = max(desired_start - pd.Timedelta(minutes=POLICY_EARLY_ARRIVE_MAX_MIN), desired_start.floor('H'))
        real_end   = min(desired_end + pd.Timedelta(hours=POLICY_LATE_PICKUP_MAX_H),   desired_end.ceil('H'))

        # 基础费
        base = self.base_fee

        # 尺寸差价（按分配柜尺寸收取；若更大柜替代则体现）
        size_up = self.size_upcharge.get(assigned_size, 0.0)

        # 晚取附加费（相对“原计划”逗留时长的超额部分）
        planned = (desired_end - desired_start).total_seconds()
        actual  = (real_end    - real_start   ).total_seconds()
        late_fee = 0.0
        if planned > 0 and actual > planned:
            ext_ratio = (actual - planned) / planned
            blocks = int(np.ceil(ext_ratio / LATE_FEE_STEP))
            late_fee = blocks * LATE_FEE_STEP * base

        return real_start, real_end, base, size_up, late_fee

    def _large_remaining_ratio(self):
        """当前仍可用的大柜占比（用于尺寸保护）。"""
        large_free = 0
        used_large = 0
        for L in self.lb.lockers:
            # 空闲定义为：当前时刻以后仍可用？这里用粗略估计：看 schedule 非满
            # 为不依赖“当前时刻”，我们直接认为：尚未被永久占满的都计为可用（保守）
            used_large += len(L.schedule) > 0 and (L.size == 'large')
            if L.size == 'large':
                large_free += 1  # 总大柜数（近似）
        large_free = large_free - used_large
        denom = self.total_large if self.total_large > 0 else 1
        return max(0.0, large_free / denom)

    def _smarter_score(self, locker: Locker, req_cat, start, end):
        """综合评分：尺寸匹配 + 人体工学 + 前瞻 + 尺寸保护"""
        req_v = self._size_value(req_cat)
        size_diff = self._size_value(locker.size) - req_v

        # 1) 尺寸匹配（越接近越好，强惩大材小用）
        size_score = 1.0 / (1 + 2.0 * max(0, size_diff))   # 正好=1，更大=下降

        # 2) 人体工学软偏好（行越接近中段越好）
        ergo_soft = 1.0 - min(1.0, abs(locker.position[0] - GRID_HEIGHT/2) / (GRID_HEIGHT/2)) * 0.6
        # 3) 前瞻：离下一次被占用的间隔越长越好（normalize by LOOKAHEAD_HOURS）
        next_start = float('inf')
        for s, e in locker.schedule:
            if s >= end:
                next_start = s
                break
        if next_start == float('inf'):
            future = 1.0
        else:
            gap_h = (next_start - end).total_seconds() / 3600
            future = max(0.0, min(1.0, gap_h / LOOKAHEAD_HOURS))

        # 4) 尺寸保护：当请求为 small/medium 却使用 large 时，在“大柜稀缺”情形惩罚
        protect_penalty = 0.0
        if locker.size == 'large' and size_diff > 0:
            remain_ratio = self._large_remaining_ratio()
            if remain_ratio < SIZE_PROTECTION_LARGE_THRESHOLD:
                protect_penalty = (SIZE_PROTECTION_LARGE_THRESHOLD - remain_ratio) * 0.8

        # 加权合成
        score = (0.40 * size_score) + (0.30 * ergo_soft) + (0.30 * future) - protect_penalty
        return score

    def _assign_strawman(self, req_cat, start, end, reachable_range):
        cands = self._get_candidates(req_cat, reachable_range)
        for L in cands:
            if L.is_available(start, end):
                return L
        return None

    def _assign_smarter(self, req_cat, start, end, reachable_range):
        cands = self._get_candidates(req_cat, reachable_range)
        avail = [L for L in cands if L.is_available(start, end)]
        if not avail:
            return None
        best, best_score = None, -1e9
        for L in avail:
            sc = self._smarter_score(L, req_cat, start, end)
            if sc > best_score:
                best, best_score = L, sc
        return best

    def run(self, heuristic='strawman'):
        rows = []
        for _, r in tqdm(self.df.iterrows(), total=len(self.df), desc=f"Simulating ({heuristic})", ncols=90):
            pkg = r['package_id']
            req_cat = self._req_category(r['min_size_ft3'])

            # ✅ 1) 直接使用 Task 3 的真实时间
            start = pd.to_datetime(r['real_deposit_dt'])
            end   = pd.to_datetime(r['real_pickup_dt'])

            # 人体工学可达性
            reach_range = reachable_row_range_for_user()

            # 选择启发式
            if heuristic == 'strawman':
                chosen = self._assign_strawman(req_cat, start, end, reach_range)
            elif heuristic == 'smarter':
                chosen = self._assign_smarter(req_cat, start, end, reach_range)
            else:
                raise ValueError("Unknown heuristic")

            # 统一的结果骨架（注意：不再区分 desired_*）
            result = {
                'package_id': pkg,
                'required_size': req_cat,
                'status': 'rejected',
                'reason': '',
                'assigned_locker_id': None,
                'assigned_locker_size': None,
                'real_start': pd.NaT,
                'real_end': pd.NaT,
                'revenue_base': 0.0,
                'revenue_size_upcharge': 0.0,
                'revenue_late_fee': 0.0,
            }

            if chosen is None:
                feas_any = len(self._get_candidates(req_cat, reach_range)) > 0
                result['reason'] = 'rejected_full' if feas_any else 'rejected_unreachable'
            else:
                # ✅ 2) 不再调用 _apply_policy，直接按 Task 3 的真实时间上锁
                chosen.book(start, end)

                # ✅ 3) 不再计算任何政策费用；若仍想保留基础费，可把 revenue_base=BASE_FEE
                result.update({
                    'status': 'accepted',
                    'reason': 'accepted_exact' if chosen.size == req_cat else 'accepted_oversize',
                    'assigned_locker_id': chosen.id,
                    'assigned_locker_size': chosen.size,
                    'real_start': start,
                    'real_end': end,
                    # 'revenue_base': BASE_FEE,               # <- 如需保留基础费，解除注释
                    # 'revenue_size_upcharge': 0.0,           # <- 不再收差价/滞纳费
                    # 'revenue_late_fee': 0.0,
                })

            rows.append(result)

        res = pd.DataFrame(rows)

        # ✅ 4) 统计口径改为真实开始时间（而不是 desired_start）
        res['date'] = pd.to_datetime(res['real_start']).dt.date
        res['hour'] = pd.to_datetime(res['real_start']).dt.hour
        return res



# =========================
# 绩效度量 & 可视化
# =========================

def compute_daily_service_level(df_result: pd.DataFrame):
    daily = df_result.groupby('date').agg(
        requests=('package_id', 'count'),
        accepted=('status', lambda s: (s == 'accepted').sum())
    ).reset_index()
    daily['service_level'] = daily['accepted'] / daily['requests']
    return daily

def compute_hourly_utilization(df_result: pd.DataFrame, total_lockers: int):
    """
    估计小时粒度的平均利用率：
    对每条已接受的预约，将其 [real_start, real_end) 覆盖到小时桶中计数。
    """
    occ = defaultdict(int)
    total_hours = 0
    for _, r in df_result[df_result['status'] == 'accepted'].iterrows():
        s = pd.to_datetime(r['real_start'])
        e = pd.to_datetime(r['real_end'])
        # 按小时迭代
        t = s.floor('H')
        while t < e:
            occ[t] += 1
            t += pd.Timedelta(hours=1)
            total_hours += 1

    if total_lockers == 0:
        total_lockers = 1
    # 汇总为“小时-of-day”的平均占用率
    if not occ:
        return pd.DataFrame({'hour': range(24), 'utilization': [0.0]*24})
    occ_df = pd.DataFrame({'ts': list(occ.keys()), 'occupied': list(occ.values())})
    occ_df['hour'] = pd.to_datetime(occ_df['ts']).dt.hour
    hourly = occ_df.groupby('hour')['occupied'].mean().reset_index()
    hourly['utilization'] = hourly['occupied'] / total_lockers
    hourly = hourly[['hour', 'utilization']]
    # 补齐 0..23
    full = pd.DataFrame({'hour': range(24)}).merge(hourly, on='hour', how='left').fillna(0.0)
    return full

def compute_revenue_breakdown(df_result: pd.DataFrame):
    acc = df_result[df_result['status'] == 'accepted']
    total = acc[['revenue_base','revenue_size_upcharge','revenue_late_fee']].sum()
    out = pd.DataFrame({
        'component': ['base','size_upcharge','late_fee'],
        'revenue': [total['revenue_base'], total['revenue_size_upcharge'], total['revenue_late_fee']]
    })
    out['revenue'] = out['revenue'].astype(float)
    return out

def plot_daily_service_level(daily_df: pd.DataFrame, out_path: str):
    plt.figure(figsize=(11,4))
    plt.plot(pd.to_datetime(daily_df['date']), daily_df['service_level'])
    plt.axhline(0.995, linestyle='--')
    plt.title('Daily Service Level')
    plt.xlabel('Date')
    plt.ylabel('Service Level')
    plt.tight_layout()
    plt.savefig(out_path, dpi=160)
    plt.close()

def plot_hourly_utilization(hourly_df: pd.DataFrame, out_path: str):
    plt.figure(figsize=(8,4))
    plt.plot(hourly_df['hour'], hourly_df['utilization'])
    plt.title('Average Utilization by Hour of Day')
    plt.xlabel('Hour')
    plt.ylabel('Utilization')
    plt.xticks(range(0,24,2))
    plt.tight_layout()
    plt.savefig(out_path, dpi=160)
    plt.close()

def plot_revenue_breakdown(rev_df: pd.DataFrame, out_path: str):
    plt.figure(figsize=(6,4))
    plt.bar(rev_df['component'], rev_df['revenue'])
    plt.title('Revenue Breakdown')
    plt.xlabel('Component')
    plt.ylabel('Revenue')
    plt.tight_layout()
    plt.savefig(out_path, dpi=160)
    plt.close()


# =========================
# 主程序
# =========================

def main():
    # 读取 Task 3 产出
    if not os.path.exists(INPUT_DEMAND_CSV):
        raise FileNotFoundError(f"未找到 Task 3 产出文件：{INPUT_DEMAND_CSV}")

    demand_df = pd.read_csv(
        INPUT_DEMAND_CSV,
        parse_dates=['real_deposit_dt','real_pickup_dt']
    )

    # （可选）仅取到 2026 年样本，且抽样 N 条用于快跑演示
    demand_df = demand_df[demand_df['real_deposit_dt'] < '2027-01-01'].copy()
    # 你可以把 20000 调大/调小
    demand_df = demand_df.head(20000).copy()

    # ——运行 strawman——
    bank_a = LockerBank(NUM_SMALL, NUM_MEDIUM, NUM_LARGE, height=GRID_HEIGHT)
    agent_a = AssignmentAgent(bank_a, demand_df)
    res_a = agent_a.run(heuristic='strawman')
    a_csv = os.path.join(OUTPUT_DIR, 'strawman_assignment_results.csv')
    res_a.to_csv(a_csv, index=False)

    # ——运行 smarter——
    bank_b = LockerBank(NUM_SMALL, NUM_MEDIUM, NUM_LARGE, height=GRID_HEIGHT)
    agent_b = AssignmentAgent(bank_b, demand_df)
    res_b = agent_b.run(heuristic='smarter')
    b_csv = os.path.join(OUTPUT_DIR, 'smarter_assignment_results.csv')
    res_b.to_csv(b_csv, index=False)

    # ——汇总&打印关键指标——
    def summarize(tag, df, total_lockers):
        sl = df['status'].value_counts(normalize=True).get('accepted', 0.0)
        daily = compute_daily_service_level(df)
        min_sl = daily['service_level'].min() if not daily.empty else 0.0
        hourly = compute_hourly_utilization(df, total_lockers)
        rev = compute_revenue_breakdown(df)
        print(f"\n[{tag}] Overall Service Level: {sl:.2%}")
        print(f"[{tag}] Min Daily Service Level: {min_sl:.2%}")
        print(f"[{tag}] Revenue (base/size_up/late): {tuple(rev['revenue'].round(2))}")
        return daily, hourly, rev

    total_lockers = bank_a.total_lockers()
    daily_a, hourly_a, rev_a = summarize('Strawman', res_a, total_lockers)
    daily_b, hourly_b, rev_b = summarize('Smarter ', res_b, total_lockers)

    # ——图表输出（各 3 张）——
    plot_daily_service_level(daily_a, os.path.join(OUTPUT_DIR, 'A_daily_service_level.png'))
    plot_hourly_utilization(hourly_a, os.path.join(OUTPUT_DIR, 'A_hourly_utilization.png'))
    plot_revenue_breakdown(rev_a, os.path.join(OUTPUT_DIR, 'A_revenue_breakdown.png'))

    plot_daily_service_level(daily_b, os.path.join(OUTPUT_DIR, 'B_daily_service_level.png'))
    plot_hourly_utilization(hourly_b, os.path.join(OUTPUT_DIR, 'B_hourly_utilization.png'))
    plot_revenue_breakdown(rev_b, os.path.join(OUTPUT_DIR, 'B_revenue_breakdown.png'))

    # ——参数落盘 & README——
    params = {
        'grid_height': GRID_HEIGHT,
        'row_height_cm': ROW_HEIGHT_CM,
        'base_floor_to_row0_cm': BASE_FLOOR_TO_ROW0_CM,
        'size_units': SIZE_UNITS,
        'user_height_dist_cm': USER_HEIGHT_DIST_CM,
        'arm_reach_offset_cm': ARM_REACH_OFFSET_CM,
        'reach_safety_margin_cm': REACH_SAFETY_MARGIN_CM,
        'policy_early_arrive_max_min': POLICY_EARLY_ARRIVE_MAX_MIN,
        'policy_late_pickup_max_h': POLICY_LATE_PICKUP_MAX_H,
        'base_fee': BASE_FEE,
        'size_upcharge': SIZE_UPCHARGE,
        'late_fee_step': LATE_FEE_STEP,
        'size_protection_large_threshold': SIZE_PROTECTION_LARGE_THRESHOLD,
        'lookahead_hours': LOOKAHEAD_HOURS,
        'num_small': NUM_SMALL,
        'num_medium': NUM_MEDIUM,
        'num_large': NUM_LARGE,
        'random_seed': RANDOM_SEED,
        'input_demand_csv': INPUT_DEMAND_CSV
    }
    with open(os.path.join(OUTPUT_DIR, 'task4_params.json'), 'w', encoding='utf-8') as f:
        json.dump(params, f, indent=2, ensure_ascii=False)

    with open(os.path.join(OUTPUT_DIR, 'README_Task4.txt'), 'w', encoding='utf-8') as f:
        f.write(
            "Task 4 Simulation Output\n"
            "- strawman_assignment_results.csv\n"
            "- smarter_assignment_results.csv\n"
            "- A_* / B_* PNG charts (service level / hourly utilization / revenue breakdown)\n"
            "- task4_params.json (parameters)\n\n"
            "Notes:\n"
            "1) 人体工学可达性使用三分位身高+行高映射的近似模型。\n"
            "2) 政策：提前 ≤90min、延后 ≤180h；更大柜差价；滞纳费每超 20% 加收 20% 基础费。\n"
            "3) Smarter 启发式包含尺寸保护与 48h 前瞻评分；阈值可在参数中调整。\n"
            "4) 如需与 Task 1/2 的最优规模/布局联动，请用其输出替换本文件头部的 NUM_* 参数。\n"
        )

    print(f"\n✅ 所有结果已输出到目录：{OUTPUT_DIR}")
    print("  - strawman_assignment_results.csv / smarter_assignment_results.csv")
    print("  - A_*.png / B_*.png 三类图表（每日服务水平、小时利用率、收入分解）")
    print("  - task4_params.json / README_Task4.txt")


if __name__ == '__main__':
    main()
