import pandas as pd
import numpy as np
import datetime
import random
from tqdm import tqdm
import os
import matplotlib.pyplot as plt

# =============================================================================
# --- Section 1: Constants from Casework Document (No changes) ---
# =============================================================================
PERIOD_CV = 0.2
DAILY_DEMAND_CV = 0.25
SIZE_PROBABILITY = {
    1: 0.08, 2: 0.12, 3: 0.15, 4: 0.12, 5: 0.08, 6: 0.06, 7: 0.05,
    8: 0.05, 9: 0.05, 10: 0.04, 11: 0.04, 12: 0.03, 13: 0.03,
    14: 0.03, 15: 0.02, 16: 0.02, 17: 0.02, 18: 0.01
}
SIZES = list(SIZE_PROBABILITY.keys())
SIZE_PROBS = list(SIZE_PROBABILITY.values())
PERIOD_DEMAND_SHARE = {
    1: 0.03, 2: 0.05, 3: 0.06, 4: 0.07, 5: 0.11, 6: 0.06, 7: 0.04,
    8: 0.10, 9: 0.10, 10: 0.06, 11: 0.08, 12: 0.11, 13: 0.13
}
DAY_OF_WEEK_SHARE = {
    0: 0.13, 1: 0.12, 2: 0.15, 3: 0.18, 4: 0.20, 5: 0.15, 6: 0.07
}
SCENARIO_TREE = {
    'start': [('1.1', 0.25), ('1.2', 0.25), ('1.3', 0.5)], '1.1': [('2.1', 0.3), ('2.2', 0.4), ('2.3', 0.3)],
    '1.2': [('2.2', 0.6), ('2.3', 0.4)], '1.3': [('2.4', 0.6), ('2.5', 0.4)], '2.1': [('3.1', 0.5), ('3.2', 0.5)],
    '2.2': [('3.1', 0.3), ('3.2', 0.4), ('3.3', 0.3)], '2.3': [('3.2', 0.6), ('3.3', 0.4)],
    '2.4': [('3.4', 0.6), ('3.5', 0.4)], '2.5': [('3.4', 0.4), ('3.5', 0.6)], '3.1': [('4.1', 0.5), ('4.2', 0.5)],
    '3.2': [('4.1', 0.3), ('4.2', 0.4), ('4.3', 0.3)], '3.3': [('4.2', 0.6), ('4.3', 0.4)],
    '3.4': [('4.3', 0.1), ('4.4', 0.6), ('4.5', 0.3)], '3.5': [('4.4', 0.4), ('4.5', 0.6)],
    '4.1': [('5.1', 0.5), ('5.2', 0.5)], '4.2': [('5.1', 0.3), ('5.2', 0.4), ('5.3', 0.3)],
    '4.3': [('5.2', 0.6), ('5.3', 0.4)], '4.4': [('5.3', 0.25), ('5.4', 0.75)], '4.5': [('5.4', 0.4), ('5.5', 0.6)]
}
SCENARIO_DEMANDS = {
    '1.1': 50000, '1.2': 60000, '1.3': 80000, '2.1': 60000, '2.2': 65000, '2.3': 70000, '2.4': 90000, '2.5': 100000,
    '3.1': 60000, '3.2': 70000, '3.3': 75000, '3.4': 100000, '3.5': 110000, '4.1': 60000, '4.2': 75000, '4.3': 80000,
    '4.4': 105000, '4.5': 120000, '5.1': 60000, '5.2': 65000, '5.3': 90000, '5.4': 110000, '5.5': 150000
}
DAILY_DEPOSIT_DIST = np.array([200, 200, 100, 100, 300, 300, 400, 400, 600, 600, 600, 600, 400, 600, 800, 600, 600, 500, 500, 400, 200, 200, 200, 200])
DEPOSIT_HOUR_PROBS = DAILY_DEPOSIT_DIST / DAILY_DEPOSIT_DIST.sum()
DAILY_PICKUP_DIST = np.array([103, 22, 38, 28, 141, 280, 547, 710, 521, 424, 506, 560, 558, 496, 517, 610, 786, 790, 720, 626, 495, 289, 183, 0])
PICKUP_HOUR_PROBS = DAILY_PICKUP_DIST / DAILY_PICKUP_DIST.sum()
START_YEAR = 2026


# =============================================================================
# --- Section 2: Helper Functions ---
# =============================================================================

def _generate_intra_hour_arrival_minutes(N, lsp_proportion=0.8, lsp_mean=15, lsp_std=5):
    if N <= 0: return []
    n_lsp = int(round(N * lsp_proportion)); n_cust = N - n_lsp
    lsp_times = np.clip(np.random.normal(loc=lsp_mean, scale=lsp_std, size=n_lsp), 0, 60)
    cust_times = np.random.uniform(0, 60, n_cust)
    all_times = np.concatenate((lsp_times, cust_times)); all_times.sort()
    return list(all_times)

### MODIFIED FUNCTION ###
def _simulate_annual_demand_path(mode='random') -> list[int]:
    """
    Simulates a 5-year demand path through the scenario tree.
    
    Args:
        mode (str): 'random' for a probabilistic path, 
                    'highest' for a deterministic path that always chooses the highest demand option.
    
    Returns:
        list[int]: A list of 5 annual demand values.
    """
    annual_demands = []
    current_node = 'start'
    for _ in range(5):
        next_states = SCENARIO_TREE[current_node]
        nodes, probabilities = zip(*next_states)
        
        if mode == 'highest':
            # Deterministic: Find the next node that has the maximum possible demand value
            chosen_node = max(nodes, key=lambda node: SCENARIO_DEMANDS[node])
        else: # Default to 'random'
            # Probabilistic: Choose the next node based on given probabilities
            chosen_node = np.random.choice(nodes, p=probabilities)
            
        annual_demands.append(SCENARIO_DEMANDS[chosen_node])
        current_node = chosen_node
        
    return annual_demands

def _generate_packages_for_one_day(num_packages: int, date: datetime.date) -> list[dict]:
    if num_packages <= 0: return []
    package_list = []
    required_sizes = np.random.choice(SIZES, size=num_packages, p=SIZE_PROBS)
    deposit_hours = np.random.choice(24, size=num_packages, p=DEPOSIT_HOUR_PROBS)
    hourly_deposit_counts = pd.Series(deposit_hours).value_counts().to_dict()
    all_deposit_datetimes = []
    for hour, count in hourly_deposit_counts.items():
        arrival_minutes = _generate_intra_hour_arrival_minutes(count)
        for minute in arrival_minutes:
            base_time = datetime.datetime.combine(date, datetime.time(hour=hour))
            all_deposit_datetimes.append(base_time + datetime.timedelta(minutes=minute))
    random.shuffle(all_deposit_datetimes)
    pickup_hours = np.random.choice(24, size=num_packages, p=PICKUP_HOUR_PROBS)
    hourly_pickup_counts = pd.Series(pickup_hours).value_counts().to_dict()
    all_pickup_minutes = []
    for hour, count in hourly_pickup_counts.items():
        arrival_minutes = np.random.uniform(0, 60, count)
        for minute in arrival_minutes: all_pickup_minutes.append((hour, minute))
    random.shuffle(all_pickup_minutes)
    for i in range(num_packages):
        desired_deposit_dt = all_deposit_datetimes[i]
        pickup_hour, pickup_minute = all_pickup_minutes[i]
        pickup_date = desired_deposit_dt.date()
        if pickup_hour < desired_deposit_dt.hour: pickup_date += datetime.timedelta(days=1)
        base_pickup_time = datetime.datetime.combine(pickup_date, datetime.time(hour=pickup_hour))
        desired_pickup_dt = base_pickup_time + datetime.timedelta(minutes=pickup_minute)
        deposit_offset_hours = random.uniform(-1.5, 180.0)
        pickup_offset_hours = random.uniform(-6.0, 6.0)
        real_deposit_dt = desired_deposit_dt + datetime.timedelta(hours=deposit_offset_hours)
        if real_deposit_dt >= desired_pickup_dt: real_deposit_dt = desired_pickup_dt - datetime.timedelta(hours=1)
        real_pickup_dt = desired_pickup_dt + datetime.timedelta(hours=pickup_offset_hours)
        package_list.append({'min_size_ft3': required_sizes[i], 'desired_deposit_dt': desired_deposit_dt,
                             'desired_pickup_dt': desired_pickup_dt, 'real_deposit_dt': real_deposit_dt,
                             'real_pickup_dt': real_pickup_dt})
    return package_list


# =============================================================================
# --- Section 3: Main Simulator Function ---
# =============================================================================

### MODIFIED FUNCTION ###
def generate_five_year_demand_instance(simulation_mode: str = 'random') -> pd.DataFrame:
    """
    Develops a locker bank demand simulator.
    
    Args:
        simulation_mode (str): Passed to _simulate_annual_demand_path. 
                               Can be 'random' or 'highest'.
    """
    print(f"--- Starting 5-Year Dynamic Demand Simulation (Mode: {simulation_mode.upper()}) ---")
    
    # This now calls the modified function with the specified mode
    annual_demands = _simulate_annual_demand_path(mode=simulation_mode)
    print(f"Simulated Annual Demand Path (Mean Targets): {annual_demands}")

    start_date = datetime.date(START_YEAR, 1, 1)
    end_date = start_date + datetime.timedelta(days=int(5 * 365.25) - 1)
    date_range = pd.to_datetime(pd.date_range(start=start_date, end=end_date, freq='D'))
    
    daily_demand_df = pd.DataFrame(date_range, columns=['date'])
    daily_demand_df['year'] = daily_demand_df['date'].dt.year
    daily_demand_df['period'] = ((daily_demand_df['date'].dt.dayofyear - 1) // 28) + 1
    daily_demand_df['period'] = daily_demand_df['period'].clip(upper=13)
    daily_demand_df['day_of_week'] = daily_demand_df['date'].dt.dayofweek
    
    all_years_dfs = []
    for year_idx, total_annual_demand in enumerate(annual_demands):
        year = START_YEAR + year_idx
        year_df_template = daily_demand_df[daily_demand_df['year'] == year].copy()
        
        all_period_dfs = []
        for period_num in range(1, 14):
            period_df = year_df_template[year_df_template['period'] == period_num].copy()
            if len(period_df) == 0: continue

            expected_period_demand = total_annual_demand * PERIOD_DEMAND_SHARE[period_num]
            period_std_dev = expected_period_demand * PERIOD_CV
            simulated_period_demand = np.random.normal(expected_period_demand, period_std_dev)
            simulated_period_demand = int(max(0, round(simulated_period_demand)))

            if len(period_df) > 0:
                mean_daily_for_period = simulated_period_demand / len(period_df)
                period_df['dow_share'] = period_df['day_of_week'].map(DAY_OF_WEEK_SHARE)
                avg_dow_share_in_period = period_df['dow_share'].mean()
                
                period_df['expected_daily'] = mean_daily_for_period * (period_df['dow_share'] / avg_dow_share_in_period)
                
                daily_std_dev = period_df['expected_daily'] * DAILY_DEMAND_CV
                period_df['simulated_daily'] = np.random.normal(period_df['expected_daily'], daily_std_dev)
                period_df['simulated_daily'] = period_df['simulated_daily'].fillna(0).round().astype(int).clip(lower=0)
                
                current_sum = period_df['simulated_daily'].sum()
                if current_sum > 0:
                    scale_factor = simulated_period_demand / current_sum
                    period_df['final_daily_demand'] = (period_df['simulated_daily'] * scale_factor).round().astype(int)
                else:
                    period_df['final_daily_demand'] = 0

                remainder = simulated_period_demand - period_df['final_daily_demand'].sum()
                if remainder > 0:
                    demand_values = period_df['final_daily_demand'].values
                    add_indices = np.random.choice(demand_values.size, size=int(remainder), replace=True)
                    np.add.at(demand_values, add_indices, 1)
                    period_df['final_daily_demand'] = demand_values
            else:
                 period_df['final_daily_demand'] = 0

            all_period_dfs.append(period_df)
        
        if all_period_dfs:
            year_df_final = pd.concat(all_period_dfs)
            all_years_dfs.append(year_df_final)

    if not all_years_dfs: return pd.DataFrame()
    
    final_demand_schedule = pd.concat(all_years_dfs)
    
    all_packages = []
    print("\nGenerating individual package details for each day...")
    for _, row in tqdm(final_demand_schedule.iterrows(), total=len(final_demand_schedule), desc="Daily Progress"):
        num_packages_today = row['final_daily_demand']
        if num_packages_today > 0:
            packages_today = _generate_packages_for_one_day(int(num_packages_today), row['date'].date())
            all_packages.extend(packages_today)
            
    print("\nSimulation complete. Finalizing DataFrame.")
    demand_instance_df = pd.DataFrame(all_packages)
    
    if not demand_instance_df.empty:
        demand_instance_df.insert(0, 'package_id', range(1, len(demand_instance_df) + 1))
    
    return demand_instance_df


# =============================================================================
# --- Section 4: Execution Block ---
# =============================================================================
if __name__ == '__main__':
    ### CHOOSE YOUR SIMULATION MODE HERE ###
    # 'random':  A different probabilistic path each time you run.
    # 'highest': A deterministic high-demand path for stress testing.
    SIMULATION_MODE = 'random' 
    
    demand_df = generate_five_year_demand_instance(simulation_mode=SIMULATION_MODE)
    
    output_folder = "Task_3_Outcome"
    os.makedirs(output_folder, exist_ok=True)

    if not demand_df.empty:
        print("\n\n--- Simulation Output ---")
        actual_total_demand = len(demand_df)
        print(f"Successfully generated {actual_total_demand:,} package demand instances over 5 years.")
        demand_df.info()
        print("\nSample of Generated Demand Data (First 5 rows):")
        print(demand_df.head())
        
        # Modify filename to reflect the simulation mode
        filename = f"task3_demand_instance_{SIMULATION_MODE}_mode.csv"
        output_filepath = os.path.join(output_folder, filename)
        
        demand_df.to_csv(output_filepath, index=False)
        print(f"\n✅ Full demand instance saved to '{output_filepath}'")

        # ================================
        # --- Section 4.1: Visualizations ---
        # ================================
        figs_dir = os.path.join(output_folder, f"figs_{SIMULATION_MODE}_mode")
        os.makedirs(figs_dir, exist_ok=True)
        
        # Helper transforms
        demand_df["sojourn_hours"] = (pd.to_datetime(demand_df["real_pickup_dt"]) - pd.to_datetime(demand_df["real_deposit_dt"])).dt.total_seconds() / 3600.0
        for col in ["desired_deposit_dt", "desired_pickup_dt", "real_deposit_dt", "real_pickup_dt"]:
            demand_df[col] = pd.to_datetime(demand_df[col])
        demand_df["real_deposit_date"] = demand_df["real_deposit_dt"].dt.date
        daily_counts = demand_df.groupby("real_deposit_date", as_index=False).size()
        daily_counts.rename(columns={"size": "num_packages"}, inplace=True)
        daily_counts["date"] = pd.to_datetime(daily_counts["real_deposit_date"])
        daily_counts = daily_counts.sort_values("date")
        daily_counts["roll28"] = daily_counts["num_packages"].rolling(28, min_periods=1).mean()

        # Fig 6: Daily demand time series
        plt.figure(figsize=(12, 6))
        plt.plot(daily_counts["date"], daily_counts["num_packages"], linewidth=1, alpha=0.7, label="Daily Packages")
        plt.plot(daily_counts["date"], daily_counts["roll28"], linewidth=2, color='red', label="28-Day Rolling Mean")
        plt.title(f"Daily Packages (Real Deposit Date) - Mode: {SIMULATION_MODE.upper()}")
        plt.xlabel("Date")
        plt.ylabel("Packages per Day")
        plt.legend()
        plt.grid(True, linestyle='--', alpha=0.6)
        fig_path = os.path.join(figs_dir, "06_daily_counts_roll28.png")
        plt.tight_layout()
        plt.savefig(fig_path, dpi=150)
        plt.show()
        print(f"Saved: {fig_path}")

        print(f"\n✅ Figures for this run saved under: {figs_dir}")
    else:
        print("\n--- Simulation resulted in an empty demand set. ---")
