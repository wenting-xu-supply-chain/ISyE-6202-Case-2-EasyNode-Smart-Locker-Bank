import pandas as pd
import numpy as np
import datetime
import random
from tqdm import tqdm

# =============================================================================
# --- Section 1: Constants from Casework Document ---
# =============================================================================

# Table 1: Package Space Requirement Probabilities
SIZE_PROBABILITY = {
    1: 0.08, 2: 0.12, 3: 0.15, 4: 0.12, 5: 0.08, 6: 0.06, 7: 0.05,
    8: 0.05, 9: 0.05, 10: 0.04, 11: 0.04, 12: 0.03, 13: 0.03,
    14: 0.03, 15: 0.02, 16: 0.02, 17: 0.02, 18: 0.01
}
SIZES = list(SIZE_PROBABILITY.keys())
SIZE_PROBS = list(SIZE_PROBABILITY.values())

# Table 2: Temporal Demand Shares and Variation
PERIOD_DEMAND_SHARE = {
    1: 0.03, 2: 0.05, 3: 0.06, 4: 0.07, 5: 0.11, 6: 0.06, 7: 0.04,
    8: 0.10, 9: 0.10, 10: 0.06, 11: 0.08, 12: 0.11, 13: 0.13
}
DAY_OF_WEEK_SHARE = {
    0: 0.13, 1: 0.12, 2: 0.15, 3: 0.18, 4: 0.20, 5: 0.15, 6: 0.07  # Monday=0, Sunday=6
}
DAILY_DEMAND_CV = 0.25

# Figure 1: Yearly Demand Scenarios
SCENARIO_TREE = {
    'start': [('1.1', 0.25), ('1.2', 0.25), ('1.3', 0.5)], '1.1': [('2.1', 0.3), ('2.2', 0.4), ('2.3', 0.3)],
    '1.2': [('2.2', 0.6), ('2.3', 0.4)], '1.3': [('2.4', 0.6), ('2.5', 0.4)], '2.1': [('3.1', 0.5), ('3.2', 0.5)],
    '2.2': [('3.1', 0.3), ('3.2', 0.4), ('3.3', 0.3)], '2.3': [('3.2', 0.6), ('3.3', 0.4)],
    '2.4': [('3.4', 0.6), ('3.5', 0.4)], '2.5': [('3.4', 0.4), ('3.5', 0.6)], '3.1': [('4.1', 0.5), ('4.2', 0.5)],
    '3.2': [('4.1', 0.3), ('4.2', 0.4), ('4.3', 0.3)], '3.3': [('4.2', 0.6), ('4.3', 0.4)],
    '3.4': [('4.3', 0.1), ('4.4', 0.6), ('4.5', 0.3)], '3.5': [('4.4', 0.4), ('4.5', 0.6)],
    '4.1': [('5.1', 0.5), ('5.2', 0.5)], '4.2': [('5.1', 0.3), ('5.2', 0.4), ('5.3', 0.3)],
    '4.3': [('5.2', 0.6), ('5.3', 0.4)], '4.4': [('5.3', 0.25), ('5.4', 0.75)], '4.5': [('5.4', 0.4), ('5.5', 0.6)]
}
SCENARIO_DEMANDS = {
    '1.1': 50000, '1.2': 60000, '1.3': 80000, '2.1': 60000, '2.2': 65000, '2.3': 70000, '2.4': 90000, '2.5': 100000,
    '3.1': 60000, '3.2': 70000, '3.3': 75000, '3.4': 100000, '3.5': 110000, '4.1': 60000, '4.2': 75000, '4.3': 80000,
    '4.4': 105000, '4.5': 120000, '5.1': 60000, '5.2': 65000, '5.3': 90000, '5.4': 110000, '5.5': 150000
}

# --- START OF FIX ---
# Table 3: Deposit and Pickup distributions.
# Normalizing the distributions by their sum to guarantee they sum to 1.
DAILY_DEPOSIT_DIST = np.array([200, 200, 100, 100, 300, 300, 400, 400, 600, 600, 600, 600, 400, 600, 800, 600, 600, 500, 500, 400, 200, 200, 200, 200])
DEPOSIT_HOUR_PROBS = DAILY_DEPOSIT_DIST / DAILY_DEPOSIT_DIST.sum()

DAILY_PICKUP_DIST = np.array([103, 22, 38, 28, 141, 280, 547, 710, 521, 424, 506, 560, 558, 496, 517, 610, 786, 790, 720, 626, 495, 289, 183, 0])
PICKUP_HOUR_PROBS = DAILY_PICKUP_DIST / DAILY_PICKUP_DIST.sum()
# --- END OF FIX ---


# Other Parameters
START_YEAR = 2026

# =============================================================================
# --- Section 2: Helper Functions ---
# =============================================================================

def _simulate_annual_demand_path() -> list[int]:
    """
    Simulates a single 5-year demand path through the scenario tree.
    """
    annual_demands = []
    current_node = 'start'
    for _ in range(5):
        next_states = SCENARIO_TREE[current_node]
        nodes = [state[0] for state in next_states]
        probabilities = [state[1] for state in next_states]
        chosen_node = np.random.choice(nodes, p=probabilities)
        demand = SCENARIO_DEMANDS[chosen_node]
        annual_demands.append(demand)
        current_node = chosen_node
    return annual_demands

def _generate_packages_for_one_day(num_packages: int, date: datetime.date) -> list[dict]:
    """
    Generates a list of package demand instances for a single day.
    """
    if num_packages <= 0:
        return []
        
    package_list = []
    
    # Generate all random variables in batches for efficiency
    required_sizes = np.random.choice(SIZES, size=num_packages, p=SIZE_PROBS)
    deposit_hours = np.random.choice(24, size=num_packages, p=DEPOSIT_HOUR_PROBS)
    pickup_hours = np.random.choice(24, size=num_packages, p=PICKUP_HOUR_PROBS)
    deposit_offsets_hours = [random.uniform(-1.5, 180.0) for _ in range(num_packages)]
    pickup_offsets_hours = [random.uniform(-6.0, 6.0) for _ in range(num_packages)]
    
    for i in range(num_packages):
        desired_deposit_dt = datetime.datetime.combine(date, datetime.time(hour=deposit_hours[i]))
        
        pickup_date = date
        if pickup_hours[i] < deposit_hours[i]:
            pickup_date += datetime.timedelta(days=1) 
        desired_pickup_dt = datetime.datetime.combine(pickup_date, datetime.time(hour=pickup_hours[i]))
        
        real_deposit_dt = desired_deposit_dt + datetime.timedelta(hours=deposit_offsets_hours[i])
        
        if real_deposit_dt >= desired_pickup_dt:
            real_deposit_dt = desired_pickup_dt - datetime.timedelta(hours=1)
            
        real_pickup_dt = desired_pickup_dt + datetime.timedelta(hours=pickup_offsets_hours[i])
        
        package_list.append({
            'min_size_ft3': required_sizes[i],
            'desired_deposit_dt': desired_deposit_dt,
            'desired_pickup_dt': desired_pickup_dt,
            'real_deposit_dt': real_deposit_dt,
            'real_pickup_dt': real_pickup_dt
        })
        
    return package_list

# =============================================================================
# --- Section 3: Main Simulator Function ---
# =============================================================================

def generate_five_year_demand_instance() -> pd.DataFrame:
    """
    Develops a locker bank demand simulator that generates instances of dynamic 
    demand across the five-year horizon.
    """
    print("--- Starting 5-Year Dynamic Demand Simulation ---")
    
    annual_demands = _simulate_annual_demand_path()
    print(f"Simulated Annual Demand Path: {annual_demands}")

    start_date = datetime.date(START_YEAR, 1, 1)
    end_date = start_date + datetime.timedelta(days=int(5 * 365.25) - 1)
    date_range = pd.to_datetime(pd.date_range(start=start_date, end=end_date, freq='D'))
    
    daily_demand_df = pd.DataFrame(date_range, columns=['date'])
    daily_demand_df['year'] = daily_demand_df['date'].dt.year
    daily_demand_df['period'] = ((daily_demand_df['date'].dt.dayofyear - 1) // 28) + 1
    daily_demand_df['period'] = daily_demand_df['period'].clip(upper=13)
    daily_demand_df['day_of_week'] = daily_demand_df['date'].dt.dayofweek
    
    all_years_dfs = []
    for year_idx, total_annual_demand in enumerate(annual_demands):
        year = START_YEAR + year_idx
        year_df = daily_demand_df[daily_demand_df['year'] == year].copy()
        
        if len(year_df) == 0:
            continue
            
        mean_daily_demand = total_annual_demand / len(year_df)
        
        year_df['period_share'] = year_df['period'].map(PERIOD_DEMAND_SHARE)
        year_df['dow_share'] = year_df['day_of_week'].map(DAY_OF_WEEK_SHARE)

        avg_period_share = year_df['period_share'].mean()
        avg_dow_share = year_df['dow_share'].mean()
        
        year_df['expected_demand'] = (mean_daily_demand * (year_df['period_share'] / avg_period_share) *
                                      (year_df['dow_share'] / avg_dow_share))

        std_dev = year_df['expected_demand'] * DAILY_DEMAND_CV
        year_df['simulated_demand'] = np.random.normal(year_df['expected_demand'], std_dev)
        
        year_df['simulated_demand'] = year_df['simulated_demand'].fillna(0).round().astype(int).clip(lower=0)
        
        current_sum = year_df['simulated_demand'].sum()
        if current_sum > 0:
            scale_factor = total_annual_demand / current_sum
            year_df['final_daily_demand'] = (year_df['simulated_demand'] * scale_factor).round().astype(int)
        else:
            year_df['final_daily_demand'] = 0
        
        remainder = total_annual_demand - year_df['final_daily_demand'].sum()
        if remainder > 0:
            demand_values = year_df['final_daily_demand'].values
            add_indices = np.random.choice(demand_values.size, size=remainder, replace=True)
            np.add.at(demand_values, add_indices, 1)
            year_df['final_daily_demand'] = demand_values
            
        all_years_dfs.append(year_df)

    if not all_years_dfs:
         return pd.DataFrame()

    daily_demand_df = pd.concat(all_years_dfs)
    
    all_packages = []
    print("\nGenerating individual package details for each day...")
    for _, row in tqdm(daily_demand_df.iterrows(), total=len(daily_demand_df), desc="Daily Progress"):
        num_packages_today = row['final_daily_demand']
        if num_packages_today > 0:
            packages_today = _generate_packages_for_one_day(int(num_packages_today), row['date'].date())
            all_packages.extend(packages_today)
            
    print("\nSimulation complete. Finalizing DataFrame.")
    demand_instance_df = pd.DataFrame(all_packages)
    
    if not demand_instance_df.empty:
        demand_instance_df.insert(0, 'package_id', range(1, len(demand_instance_df) + 1))
    
    return demand_instance_df

# =============================================================================
# --- Section 4: Execution Block ---
# =============================================================================
if __name__ == '__main__':
    # Add the 'os' import at the very top of your script
    import os
    
    # Generate one full instance of the 5-year demand
    demand_df = generate_five_year_demand_instance()
    
    if not demand_df.empty:
        print("\n\n--- Simulation Output ---")
        print(f"Successfully generated {len(demand_df):,} package demand instances over 5 years.")
        
        print("\nDataFrame Info:")
        demand_df.info()
        
        print("\nSample of Generated Demand Data (First 5 rows):")
        print(demand_df.head())
        
        print("\nDescriptive Statistics for Package Size:")
        print(demand_df['min_size_ft3'].describe())
        
        # --- Create an output folder and define the output path ---
        output_folder = "Task_3_Outcome"
        os.makedirs(output_folder, exist_ok=True) # This creates the folder

        filename = "task3_demand_instance.csv"
        output_filepath = os.path.join(output_folder, filename)
        
        # Save the output to the new folder
        demand_df.to_csv(output_filepath, index=False)
        print(f"\nâœ… Full demand instance saved to '{output_filepath}'")
    else:
        print("\n--- Simulation resulted in an empty demand set. ---")
