# -*- coding: utf-8 -*-
"""
Task 5 - Locker Bank Operation Simulator (Integrated with Task 4 Heuristics)
Author: (your name)
Last Update: 2025-10-10

功能：
- 集成 Task 4 的启发式（strawman / smarter）与政策/人体工学约束
- 运行 Task 5 的运营仿真，输出 KPI、CSV 与可视化图

依赖：
- pandas, numpy, matplotlib, tqdm

输入：
- Task 3 产出 CSV（默认：Task_3_Outcome/task3_demand_instance_two_level_cv.csv）
"""

import os, json, math, warnings
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from tqdm import tqdm
from collections import defaultdict

warnings.filterwarnings("ignore", category=pd.errors.SettingWithCopyWarning)

# =========================
# 全局参数（可按需调整）
# =========================
# ——输入/输出——
INPUT_DEMAND_CSV = "Task_3_Outcome/task3_demand_instance_two_level_cv.csv"
OUT_DIR = "Task_5_Outcome"
os.makedirs(OUT_DIR, exist_ok=True)

# ——柜体网格参数——
GRID_HEIGHT = 15                 # 垂直行数
ROW_HEIGHT_CM = 10               # 每行高度（cm）
BASE_FLOOR_TO_ROW0_CM = 30       # 地面到第0行中线（cm）

# ——尺寸映射（单位格数）——
SIZE_UNITS = {'small': 1, 'medium': 2, 'large': 3}

# ——人体工学（简单分布示例，可替换为真实参数）——
USER_HEIGHT_DIST_CM = {'p05': 155, 'p50': 170, 'p95': 185}
ARM_REACH_OFFSET_CM = 70
REACH_SAFETY_MARGIN_CM = 10

# ——政策与定价（示例值，可按案例修正）——
POLICY_EARLY_ARRIVE_MAX_MIN = 90      # 提前 ≤90 分钟
POLICY_LATE_PICKUP_MAX_H = 180        # 延后 ≤180 小时
BASE_FEE = 5.0
SIZE_UPCHARGE = {'small': 0.0, 'medium': 1.5, 'large': 3.0}  # 以分配柜尺寸计
LATE_FEE_STEP = 0.20                  # 每超 20% 收 20% 基础费

# ——“更聪明”启发式：前瞻与尺寸保护——
LOOKAHEAD_HOURS = 48
SIZE_PROTECTION_LARGE_THRESHOLD = 0.15

# ——随机性与复现——
RANDOM_SEED = 20251010
np.random.seed(RANDOM_SEED)

# ——基线柜体配置（可替换为 Task 1 结果）——
NUM_SMALL = 140
NUM_MEDIUM = 164
NUM_LARGE = 96

# ——SLA 目标（逐日）——
SLA_DAILY_TARGET = 0.995

# ——仿真设置——
EVAL_CUTOFF_DATE = "2027-01-01"   # 只取至 2026 年（演示用）
MAX_RECORDS = 20000               # 为加速演示，可调大/调小
WARMUP_DAYS = 2.0                 # warm-up 天数（用于评估过滤）
REPLICATIONS = 1                  # Monte Carlo 轮次（可≥10 做稳定区间）

# =========================
# 工具函数
# =========================
def row_to_height_cm(row_idx: int) -> float:
    return BASE_FLOOR_TO_ROW0_CM + row_idx * ROW_HEIGHT_CM

def sample_user_height_cm() -> float:
    r = np.random.rand()
    if r < 0.2:
        return np.random.normal(USER_HEIGHT_DIST_CM['p05'], 2.5)
    elif r < 0.8:
        return np.random.normal(USER_HEIGHT_DIST_CM['p50'], 3.0)
    else:
        return np.random.normal(USER_HEIGHT_DIST_CM['p95'], 2.5)

def reachable_row_range_for_user() -> tuple[int, int]:
    h = sample_user_height_cm()
    reach_max_cm = h + ARM_REACH_OFFSET_CM - REACH_SAFETY_MARGIN_CM
    reach_min_cm = max(0, h * 0.35)
    max_row = int(round((reach_max_cm - BASE_FLOOR_TO_ROW0_CM) / ROW_HEIGHT_CM))
    min_row = int(round((reach_min_cm - BASE_FLOOR_TO_ROW0_CM) / ROW_HEIGHT_CM))
    min_row = max(0, min_row)
    max_row = min(GRID_HEIGHT - 1, max_row)
    if min_row > max_row:
        return 0, GRID_HEIGHT - 1
    return min_row, max_row

def ceil_int(x):
    return int(math.ceil(float(x)))

def ensure_int_ft3(val, lo=1, hi=18):
    if pd.isna(val):
        return lo
    v = ceil_int(val)
    return max(lo, min(hi, v))

# =========================
# 数据结构（Task 4 复用）
# =========================
class Locker:
    def __init__(self, locker_id, size_category, position_rc):
        self.id = locker_id
        self.size = size_category              # 'small'/'medium'/'large'
        self.position = position_rc            # (row, col)
        self.schedule = []                     # [(start, end), ...]

    def is_available(self, start, end):
        for s, e in self.schedule:
            if start < e and end > s:  # overlap
                return False
        return True

    def book(self, start, end):
        self.schedule.append((start, end))
        self.schedule.sort(key=lambda x: x[0])

class LockerBank:
    """顺序堆叠布局（列满换列）"""
    def __init__(self, num_s, num_m, num_l, height=GRID_HEIGHT):
        self.height = height
        self.lockers = []
        self._create_layout(num_s, num_m, num_l)

    def _create_layout(self, num_s, num_m, num_l):
        specs = [('small', num_s), ('medium', num_m), ('large', num_l)]
        current_row, current_col = 0, 0
        lid = 0
        for size, cnt in specs:
            h_units = SIZE_UNITS[size]
            for _ in range(cnt):
                if current_row + h_units > self.height:
                    current_row = 0
                    current_col += 1
                center_row = current_row + (h_units // 2)
                self.lockers.append(Locker(lid, size, (center_row, current_col)))
                current_row += h_units
                lid += 1

    def total_lockers(self):
        return len(self.lockers)

# =========================
# Task 4 启发式 Agent（加强版）
# =========================
class AssignmentAgent:
    def __init__(self, locker_bank: LockerBank):
        self.lb = locker_bank
        self.req_size_map = self._build_req_size_map()
        self.base_fee = BASE_FEE
        self.size_upcharge = SIZE_UPCHARGE
        self.total_large = sum(1 for L in self.lb.lockers if L.size == 'large')

    @staticmethod
    def _build_req_size_map():
        m = {}
        for s in range(1, 4): m[s] = 'small'
        for s in range(4, 10): m[s] = 'medium'
        for s in range(10, 19): m[s] = 'large'
        return m

    @staticmethod
    def _size_value(cat):
        return SIZE_UNITS[cat]

    def _user_reachable(self, locker: Locker, reachable_range):
        rmin, rmax = reachable_range
        return rmin <= locker.position[0] <= rmax

    def _get_candidates(self, req_cat, reachable_range):
        req_v = self._size_value(req_cat)
        feas = [L for L in self.lb.lockers if self._size_value(L.size) >= req_v and self._user_reachable(L, reachable_range)]
        feas.sort(key=lambda L: (self._size_value(L.size) - req_v, L.position[1], abs(L.position[0] - GRID_HEIGHT//2)))
        return feas

    def _large_remaining_ratio(self):
        # 近似：有日程记录的算占用；仅用于趋势保护
        used_large = sum(1 for L in self.lb.lockers if L.size=='large' and len(L.schedule)>0)
        remain = max(0, self.total_large - used_large)
        denom = max(1, self.total_large)
        return remain / denom

    def _smarter_score(self, locker: Locker, req_cat, start, end):
        req_v = self._size_value(req_cat)
        size_diff = self._size_value(locker.size) - req_v
        size_score = 1.0 / (1 + 2.0 * max(0, size_diff))
        ergo_soft = 1.0 - min(1.0, abs(locker.position[0] - GRID_HEIGHT/2) / (GRID_HEIGHT/2)) * 0.6
        # 前瞻
        next_start = float('inf')
        for s, e in locker.schedule:
            if s >= end:
                next_start = s
                break
        if next_start == float('inf'):
            future = 1.0
        else:
            gap_h = (next_start - end).total_seconds() / 3600
            future = max(0.0, min(1.0, gap_h / LOOKAHEAD_HOURS))
        # 尺寸保护
        protect_penalty = 0.0
        if locker.size == 'large' and size_diff > 0:
            remain_ratio = self._large_remaining_ratio()
            if remain_ratio < SIZE_PROTECTION_LARGE_THRESHOLD:
                protect_penalty = (SIZE_PROTECTION_LARGE_THRESHOLD - remain_ratio) * 0.8
        return (0.40 * size_score) + (0.30 * ergo_soft) + (0.30 * future) - protect_penalty

    def _apply_policy_and_price(self, desired_start, desired_end, assigned_size, req_size):
        # 裁剪
        real_start = max(desired_start - pd.Timedelta(minutes=POLICY_EARLY_ARRIVE_MAX_MIN), desired_start.floor('H'))
        real_end   = min(desired_end   + pd.Timedelta(hours=POLICY_LATE_PICKUP_MAX_H),     desired_end.ceil('H'))
        # 收费
        base = self.base_fee
        upc = self.size_upcharge.get(assigned_size, 0.0)
        planned = (desired_end - desired_start).total_seconds()
        actual  = (real_end    - real_start   ).total_seconds()
        late_fee = 0.0
        if planned > 0 and actual > planned:
            ext_ratio = (actual - planned)/planned
            blocks = int(math.ceil(ext_ratio / LATE_FEE_STEP))
            late_fee = blocks * LATE_FEE_STEP * base
        return real_start, real_end, base, upc, late_fee

    # ——两种启发式——
    def assign_strawman(self, req_cat, start, end, reachable_range):
        for L in self._get_candidates(req_cat, reachable_range):
            if L.is_available(start, end):
                return L
        return None

    def assign_smarter(self, req_cat, start, end, reachable_range):
        cands = [L for L in self._get_candidates(req_cat, reachable_range) if L.is_available(start, end)]
        if not cands:
            return None
        best, sc = None, -1e9
        for L in cands:
            s = self._smarter_score(L, req_cat, start, end)
            if s > sc:
                best, sc = L, s
        return best

# =========================
# KPI & 可视化
# =========================
def compute_daily_service_level(df_result: pd.DataFrame):
    g = df_result.groupby('date').agg(
        requests=('package_id','count'),
        accepted=('status', lambda s: (s=='accepted').sum())
    ).reset_index()
    g['service_level'] = g['accepted'] / g['requests']
    return g

def compute_hourly_utilization(df_result: pd.DataFrame, total_lockers: int):
    acc = df_result[df_result['status']=='accepted'].copy()
    if acc.empty:
        return pd.DataFrame({'hour': range(24), 'utilization': [0.0]*24})
    occ = defaultdict(int)
    for _, r in acc.iterrows():
        t = pd.to_datetime(r['real_start']).floor('H')
        end = pd.to_datetime(r['real_end'])
        while t < end:
            occ[t] += 1
            t += pd.Timedelta(hours=1)
    df = pd.DataFrame({'ts': list(occ.keys()), 'occupied': list(occ.values())})
    df['hour'] = pd.to_datetime(df['ts']).dt.hour
    hourly = df.groupby('hour')['occupied'].mean().reset_index()
    hourly['utilization'] = hourly['occupied'] / max(1, total_lockers)
    return pd.DataFrame({'hour': range(24)}).merge(hourly[['hour','utilization']], on='hour', how='left').fillna(0.0)

def compute_revenue_breakdown(df_result: pd.DataFrame):
    acc = df_result[df_result['status']=='accepted']
    tot = acc[['revenue_base','revenue_size_upcharge','revenue_late_fee']].sum()
    return pd.DataFrame({
        'component': ['base','size_up','late_fee'],
        'revenue': [float(tot.get('revenue_base',0.0)),
                    float(tot.get('revenue_size_upcharge',0.0)),
                    float(tot.get('revenue_late_fee',0.0))]
    })

def plot_daily_service_level(daily_df, path):
    plt.figure(figsize=(11,4))
    plt.plot(pd.to_datetime(daily_df['date']), daily_df['service_level'])
    plt.axhline(SLA_DAILY_TARGET, linestyle='--')
    plt.title('Daily Service Level')
    plt.xlabel('Date'); plt.ylabel('Service Level')
    plt.tight_layout(); plt.savefig(path, dpi=160); plt.close()

def plot_hourly_utilization(hourly_df, path):
    plt.figure(figsize=(8,4))
    plt.plot(hourly_df['hour'], hourly_df['utilization'])
    plt.title('Average Utilization by Hour of Day')
    plt.xlabel('Hour'); plt.ylabel('Utilization')
    plt.xticks(range(0,24,2)); plt.tight_layout(); plt.savefig(path, dpi=160); plt.close()

def plot_revenue_breakdown(rev_df, path):
    plt.figure(figsize=(6,4))
    plt.bar(rev_df['component'], rev_df['revenue'])
    plt.title('Revenue Breakdown')
    plt.xlabel('Component'); plt.ylabel('Revenue')
    plt.tight_layout(); plt.savefig(path, dpi=160); plt.close()

# =========================
# Task 5 仿真器（集成 Task 4 Agent）
# =========================
class LockerBankSimulator:
    def __init__(self, locker_bank: LockerBank, demand_df: pd.DataFrame, agent: AssignmentAgent,
                 heuristic='smarter', warmup_days=WARMUP_DAYS):
        self.lb = locker_bank
        self.demand = demand_df.copy()
        self.agent = agent
        self.heuristic = heuristic
        self.warmup_days = warmup_days
        self.results = []

    def _req_category(self, min_size_ft3):
        v = ensure_int_ft3(min_size_ft3)
        if   1 <= v <= 3:  return 'small'
        elif 4 <= v <= 9:  return 'medium'
        else:              return 'large'

    def _assign_once(self, req_cat, start, end, reach_range):
        if self.heuristic == 'strawman':
            return self.agent.assign_strawman(req_cat, start, end, reach_range)
        elif self.heuristic == 'smarter':
            return self.agent.assign_smarter(req_cat, start, end, reach_range)
        else:
            raise ValueError("Unknown heuristic")

    def run(self):
        if self.demand.empty:
            print("No demand!")
            return
        start_ts = self.demand['real_deposit_dt'].min()
        warmup_cut = start_ts + pd.Timedelta(days=self.warmup_days)

        rows = []
        for _, r in tqdm(self.demand.iterrows(), total=len(self.demand),
                         desc=f"Simulating ({self.heuristic})", ncols=90):
            pkg = r['package_id']
            req_cat = self._req_category(r['min_size_ft3'])
            desired_start = pd.to_datetime(r['real_deposit_dt'])
            desired_end   = pd.to_datetime(r['real_pickup_dt'])
            reach_range = reachable_row_range_for_user()

            chosen = self._assign_once(req_cat, desired_start, desired_end, reach_range)

            row = {
                'package_id': pkg,
                'required_size': req_cat,
                'status': 'rejected',
                'reason': '',
                'assigned_locker_id': None,
                'assigned_locker_size': None,
                'desired_start': desired_start,
                'desired_end': desired_end,
                'real_start': pd.NaT,
                'real_end': pd.NaT,
                'revenue_base': 0.0,
                'revenue_size_upcharge': 0.0,
                'revenue_late_fee': 0.0,
                'date': desired_start.date(),
                'hour': desired_start.hour,
                'keep_for_eval': desired_start >= warmup_cut
            }

            if chosen is None:
                feas_any = len(self.agent._get_candidates(req_cat, reach_range)) > 0
                row['reason'] = 'rejected_full' if feas_any else 'rejected_unreachable'
            else:
                rs, re, base, upc, late = self.agent._apply_policy_and_price(desired_start, desired_end, chosen.size, req_cat)
                chosen.book(rs, re)
                row.update({
                    'status': 'accepted',
                    'reason': 'accepted_exact' if chosen.size == req_cat else 'accepted_oversize',
                    'assigned_locker_id': chosen.id,
                    'assigned_locker_size': chosen.size,
                    'real_start': rs,
                    'real_end': re,
                    'revenue_base': base,
                    'revenue_size_upcharge': upc,
                    'revenue_late_fee': late
                })
            rows.append(row)

        self.results = pd.DataFrame(rows)

    def summarize(self, tag: str):
        if self.results is None or len(self.results)==0:
            print("No results to summarize.")
            return None

        res = self.results.copy()
        eval_df = res[res['keep_for_eval']].copy()

        # 逐日 SLA
        daily = compute_daily_service_level(eval_df)
        min_daily_sla = daily['service_level'].min() if not daily.empty else 0.0
        breach_days = int((daily['service_level'] < SLA_DAILY_TARGET).sum()) if not daily.empty else 0

        # 利用率（小时）
        total_lockers = self.lb.total_lockers()
        hourly = compute_hourly_utilization(eval_df, total_lockers)

        # 收入拆解
        rev = compute_revenue_breakdown(eval_df)

        # 收入/成本/利润（成本可放到 Task 6 综合，这里给最小成本模型示例）
        # 你也可将 CapEx/Opex 与 Task 5 的版本保持一致，这里仅聚焦收入端
        total_revenue = rev['revenue'].sum()
        overall_sl = (eval_df['status']=='accepted').mean()

        # 打印摘要
        print(f"\n[{tag}]  Overall SL: {overall_sl:.2%} | Min Daily SL: {min_daily_sla:.2%} | Breach Days: {breach_days}")
        print(f"[{tag}]  Revenue (base, size_up, late): {tuple(rev['revenue'].round(2))}")

        # 落盘
        prefix = 'A_' if tag.lower().startswith('straw') else 'B_'
        eval_df.to_csv(os.path.join(OUT_DIR, f"{prefix}results_eval.csv"), index=False)
        daily.to_csv(os.path.join(OUT_DIR, f"{prefix}daily_service_level.csv"), index=False)
        hourly.to_csv(os.path.join(OUT_DIR, f"{prefix}hourly_utilization.csv"), index=False)
        rev.to_csv(os.path.join(OUT_DIR, f"{prefix}revenue_breakdown.csv"), index=False)

        # 图
        plot_daily_service_level(daily, os.path.join(OUT_DIR, f"{prefix}daily_service_level.png"))
        plot_hourly_utilization(hourly, os.path.join(OUT_DIR, f"{prefix}hourly_utilization.png"))
        plot_revenue_breakdown(rev, os.path.join(OUT_DIR, f"{prefix}revenue_breakdown.png"))

        return {
            'results': eval_df,
            'daily': daily,
            'hourly': hourly,
            'rev': rev,
            'overall_sl': overall_sl,
            'min_daily_sla': min_daily_sla,
            'breach_days': breach_days,
            'total_revenue': float(total_revenue)
        }

# =========================
# 主程序
# =========================
def main():
    # 读取 Task 3 产出
    if not os.path.exists(INPUT_DEMAND_CSV):
        raise FileNotFoundError(f"未找到 Task 3 产出文件：{INPUT_DEMAND_CSV}")

    demand_df = pd.read_csv(
        INPUT_DEMAND_CSV,
        parse_dates=['real_deposit_dt','real_pickup_dt']
    )
    # 过滤 & 抽样（演示）
    demand_df = demand_df[demand_df['real_deposit_dt'] < EVAL_CUTOFF_DATE].copy()
    if MAX_RECORDS is not None:
        demand_df = demand_df.head(MAX_RECORDS).copy()

    # 建柜（可替换为 Task 1 输出）
    bank1 = LockerBank(NUM_SMALL, NUM_MEDIUM, NUM_LARGE, height=GRID_HEIGHT)
    bank2 = LockerBank(NUM_SMALL, NUM_MEDIUM, NUM_LARGE, height=GRID_HEIGHT)  # 另一份以便独立试验

    # 启发式 Agent（各自独立，避免 schedule 共享）
    agent_straw = AssignmentAgent(bank1)
    agent_smart = AssignmentAgent(bank2)

    # ——仿真：strawman——
    sim_a = LockerBankSimulator(bank1, demand_df, agent_straw, heuristic='strawman', warmup_days=WARMUP_DAYS)
    sim_a.run()
    summ_a = sim_a.summarize(tag='Strawman')

    # ——仿真：smarter——
    sim_b = LockerBankSimulator(bank2, demand_df, agent_smart, heuristic='smarter', warmup_days=WARMUP_DAYS)
    sim_b.run()
    summ_b = sim_b.summarize(tag='Smarter')

    # ——总体说明与参数落盘——
    params = {
        'input_csv': INPUT_DEMAND_CSV,
        'grid_height': GRID_HEIGHT,
        'row_height_cm': ROW_HEIGHT_CM,
        'base_floor_to_row0_cm': BASE_FLOOR_TO_ROW0_CM,
        'size_units': SIZE_UNITS,
        'user_height_dist_cm': USER_HEIGHT_DIST_CM,
        'arm_reach_offset_cm': ARM_REACH_OFFSET_CM,
        'reach_safety_margin_cm': REACH_SAFETY_MARGIN_CM,
        'policy': {
            'early_arrive_max_min': POLICY_EARLY_ARRIVE_MAX_MIN,
            'late_pickup_max_h': POLICY_LATE_PICKUP_MAX_H,
            'base_fee': BASE_FEE,
            'size_upcharge': SIZE_UPCHARGE,
            'late_fee_step': LATE_FEE_STEP
        },
        'lookahead_hours': LOOKAHEAD_HOURS,
        'size_protection_large_threshold': SIZE_PROTECTION_LARGE_THRESHOLD,
        'num_small': NUM_SMALL,
        'num_medium': NUM_MEDIUM,
        'num_large': NUM_LARGE,
        'random_seed': RANDOM_SEED,
        'sla_daily_target': SLA_DAILY_TARGET,
        'eval_cutoff_date': EVAL_CUTOFF_DATE,
        'max_records': MAX_RECORDS,
        'warmup_days': WARMUP_DAYS,
        'replications': REPLICATIONS
    }
    with open(os.path.join(OUT_DIR, 'task5_params.json'), 'w', encoding='utf-8') as f:
        json.dump(params, f, indent=2, ensure_ascii=False)

    with open(os.path.join(OUT_DIR, 'README_Task5.txt'), 'w', encoding='utf-8') as f:
        f.write(
            "Task 5 Integrated Simulation (with Task 4 Heuristics)\n"
            "- A_* for Strawman; B_* for Smarter\n"
            "- *_results_eval.csv: warm-up 之后的评估明细\n"
            "- *_daily_service_level.csv / *_hourly_utilization.csv / *_revenue_breakdown.csv\n"
            "- 对比图：daily_service_level.png / hourly_utilization.png / revenue_breakdown.png\n"
            "Notes:\n"
            "1) 人体工学：按行高与身高分布抽样，作为可达硬约束；并在评分中加入软偏好。\n"
            "2) 政策：提前 ≤90min、延后 ≤180h；更大柜差价；滞纳费按超时分段。\n"
            "3) Smarter 启发式含 48h 前瞻与大柜尺寸保护。\n"
            "4) SLA 以“逐日服务水平”校验，目标 99.5%。\n"
        )

    print(f"\n✅ 所有结果已输出至目录：{OUT_DIR}")
    print("   - A_*.csv / B_*.csv 明细与聚合")
    print("   - A_*.png / B_*.png 三类图（SLA、Utilization、Revenue）")
    print("   - task5_params.json / README_Task5.txt")

if __name__ == '__main__':
    main()
